//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AppPagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAppPages(projectId?: string | null | undefined, tags?: string[] | null | undefined, excludedTags?: string[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<AppPageDto[]> {
        let url_ = this.baseUrl + "/api/v1/public/app-pages?";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (tags !== undefined && tags !== null)
            tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
        if (excludedTags !== undefined && excludedTags !== null)
            excludedTags && excludedTags.forEach(item => { url_ += "excludedTags=" + encodeURIComponent("" + item) + "&"; });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppPages(_response);
        });
    }

    protected processGetAppPages(response: Response): Promise<AppPageDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppPageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppPageDto[]>(null as any);
    }

    getAppPage(appPageId: string, signal?: AbortSignal): Promise<AppPageDto> {
        let url_ = this.baseUrl + "/api/v1/public/app-pages/{appPageId}";
        if (appPageId === undefined || appPageId === null)
            throw new Error("The parameter 'appPageId' must be defined.");
        url_ = url_.replace("{appPageId}", encodeURIComponent("" + appPageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppPage(_response);
        });
    }

    protected processGetAppPage(response: Response): Promise<AppPageDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPageDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppPageDto>(null as any);
    }
}

export class AppsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAppInstallation(deviceIdentifier: string, appIndentifier: string, signal?: AbortSignal): Promise<AppInstallationDto> {
        let url_ = this.baseUrl + "/api/v1/public/apps/appinstallations?";
        if (deviceIdentifier === undefined || deviceIdentifier === null)
            throw new Error("The parameter 'deviceIdentifier' must be defined and cannot be null.");
        else
            url_ += "deviceIdentifier=" + encodeURIComponent("" + deviceIdentifier) + "&";
        if (appIndentifier === undefined || appIndentifier === null)
            throw new Error("The parameter 'appIndentifier' must be defined and cannot be null.");
        else
            url_ += "appIndentifier=" + encodeURIComponent("" + appIndentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppInstallation(_response);
        });
    }

    protected processGetAppInstallation(response: Response): Promise<AppInstallationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppInstallationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppInstallationDto>(null as any);
    }

    registerAppInstallation(installationCommand: RegisterAppInstallationCommand, signal?: AbortSignal): Promise<AppInstallationDto> {
        let url_ = this.baseUrl + "/api/v1/public/apps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installationCommand);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterAppInstallation(_response);
        });
    }

    protected processRegisterAppInstallation(response: Response): Promise<AppInstallationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppInstallationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppInstallationDto>(null as any);
    }

    unregisterAppInstallation(installationCommand: UnregisterAppInstallationCommand, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/apps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installationCommand);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnregisterAppInstallation(_response);
        });
    }

    protected processUnregisterAppInstallation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAppSetting(appIdentifier: string, key: string, signal?: AbortSignal): Promise<ClientSettingDto> {
        let url_ = this.baseUrl + "/api/v1/public/apps/setting?";
        if (appIdentifier === undefined || appIdentifier === null)
            throw new Error("The parameter 'appIdentifier' must be defined and cannot be null.");
        else
            url_ += "appIdentifier=" + encodeURIComponent("" + appIdentifier) + "&";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAppSetting(_response);
        });
    }

    protected processGetAppSetting(response: Response): Promise<ClientSettingDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSettingDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSettingDto>(null as any);
    }

    updateAppSetting(appIdentifier: string, key: string, value: string, signal?: AbortSignal): Promise<ClientSettingDto> {
        let url_ = this.baseUrl + "/api/v1/public/apps/setting?";
        if (appIdentifier === undefined || appIdentifier === null)
            throw new Error("The parameter 'appIdentifier' must be defined and cannot be null.");
        else
            url_ += "appIdentifier=" + encodeURIComponent("" + appIdentifier) + "&";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAppSetting(_response);
        });
    }

    protected processUpdateAppSetting(response: Response): Promise<ClientSettingDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSettingDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSettingDto>(null as any);
    }
}

export class ContextObjectsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getContextObjects(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, projectIds?: string[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfContextObjectDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContextObjects(_response);
        });
    }

    protected processGetContextObjects(response: Response): Promise<PaginatedListOfContextObjectDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfContextObjectDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfContextObjectDto>(null as any);
    }

    getContextObject(contextObjectId: string, signal?: AbortSignal): Promise<ContextObjectDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContextObject(_response);
        });
    }

    protected processGetContextObject(response: Response): Promise<ContextObjectDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContextObjectDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContextObjectDetailsDto>(null as any);
    }

    getContextObjectInstances(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, projectIds?: string[] | null | undefined, contextObjectIds?: string[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfContextObjectInstanceDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/instances?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (contextObjectIds !== undefined && contextObjectIds !== null)
            contextObjectIds && contextObjectIds.forEach(item => { url_ += "contextObjectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContextObjectInstances(_response);
        });
    }

    protected processGetContextObjectInstances(response: Response): Promise<PaginatedListOfContextObjectInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfContextObjectInstanceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfContextObjectInstanceDto>(null as any);
    }

    createContextObjectInstance(contextObjectId: string, signal?: AbortSignal): Promise<ContextObjectInstanceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContextObjectInstance(_response);
        });
    }

    protected processCreateContextObjectInstance(response: Response): Promise<ContextObjectInstanceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContextObjectInstanceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContextObjectInstanceDetailsDto>(null as any);
    }

    getContextObjectInstance(contextObjectId: string, contextObjectInstanceId: string, signal?: AbortSignal): Promise<ContextObjectInstanceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances/{contextObjectInstanceId}";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined.");
        url_ = url_.replace("{contextObjectInstanceId}", encodeURIComponent("" + contextObjectInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContextObjectInstance(_response);
        });
    }

    protected processGetContextObjectInstance(response: Response): Promise<ContextObjectInstanceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContextObjectInstanceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContextObjectInstanceDetailsDto>(null as any);
    }

    updateContextObjectInstance(contextObjectId: string, contextObjectInstanceId: string, command: UpdateContextObjectInstanceCommand, signal?: AbortSignal): Promise<ContextObjectInstanceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances/{contextObjectInstanceId}";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined.");
        url_ = url_.replace("{contextObjectInstanceId}", encodeURIComponent("" + contextObjectInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContextObjectInstance(_response);
        });
    }

    protected processUpdateContextObjectInstance(response: Response): Promise<ContextObjectInstanceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContextObjectInstanceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContextObjectInstanceDetailsDto>(null as any);
    }

    deleteContextObjectInstance(contextObjectId: string, contextObjectInstanceId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances/{contextObjectInstanceId}";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined.");
        url_ = url_.replace("{contextObjectInstanceId}", encodeURIComponent("" + contextObjectInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContextObjectInstance(_response);
        });
    }

    protected processDeleteContextObjectInstance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    generateContextObjectShareQrCode(contextObjectId: string, sharingOptionId: string, appId: string, signal?: AbortSignal): Promise<QrCodeDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/generate-share-qr-code?";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined and cannot be null.");
        else
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateContextObjectShareQrCode(_response);
        });
    }

    protected processGenerateContextObjectShareQrCode(response: Response): Promise<QrCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QrCodeDto>(null as any);
    }

    useContextObjectShareQrCode(contextObjectId: string, sharingOptionId: string, sharedById: string, token: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/use-share-qr-code?";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (sharedById === undefined || sharedById === null)
            throw new Error("The parameter 'sharedById' must be defined and cannot be null.");
        else
            url_ += "sharedById=" + encodeURIComponent("" + sharedById) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUseContextObjectShareQrCode(_response);
        });
    }

    protected processUseContextObjectShareQrCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    generateContextObjectInstanceShareQrCode(contextObjectId: string, contextObjectInstanceId: string, sharingOptionId: string, appId: string, signal?: AbortSignal): Promise<QrCodeDto> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances/{contextObjectInstanceId}/generate-share-qr-code?";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined.");
        url_ = url_.replace("{contextObjectInstanceId}", encodeURIComponent("" + contextObjectInstanceId));
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined and cannot be null.");
        else
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateContextObjectInstanceShareQrCode(_response);
        });
    }

    protected processGenerateContextObjectInstanceShareQrCode(response: Response): Promise<QrCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QrCodeDto>(null as any);
    }

    useContextObjectInstanceShareQrCode(contextObjectId: string, contextObjectInstanceId: string, sharingOptionId: string, sharedById: string, token: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/context-objects/{contextObjectId}/instances/{contextObjectInstanceId}/use-share-qr-code?";
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined.");
        url_ = url_.replace("{contextObjectId}", encodeURIComponent("" + contextObjectId));
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined.");
        url_ = url_.replace("{contextObjectInstanceId}", encodeURIComponent("" + contextObjectInstanceId));
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (sharedById === undefined || sharedById === null)
            throw new Error("The parameter 'sharedById' must be defined and cannot be null.");
        else
            url_ += "sharedById=" + encodeURIComponent("" + sharedById) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUseContextObjectInstanceShareQrCode(_response);
        });
    }

    protected processUseContextObjectInstanceShareQrCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CurrentUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    currentUserExists(signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/exists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrentUserExists(_response);
        });
    }

    protected processCurrentUserExists(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DevicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getDevices(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfDeviceDto> {
        let url_ = this.baseUrl + "/api/v1/public/devices?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevices(_response);
        });
    }

    protected processGetDevices(response: Response): Promise<PaginatedListOfDeviceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfDeviceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfDeviceDto>(null as any);
    }

    getDevice(deviceId: string, signal?: AbortSignal): Promise<DeviceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevice(_response);
        });
    }

    protected processGetDevice(response: Response): Promise<DeviceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceDetailsDto>(null as any);
    }
}

export class FilesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getFile(fileId: string, size?: number | null | undefined, width?: number | null | undefined, height?: number | null | undefined, x?: number | null | undefined, y?: number | null | undefined, webp?: boolean | null | undefined, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/public/files/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (size !== undefined && size !== null)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (width !== undefined && width !== null)
            url_ += "w=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "h=" + encodeURIComponent("" + height) + "&";
        if (x !== undefined && x !== null)
            url_ += "x=" + encodeURIComponent("" + x) + "&";
        if (y !== undefined && y !== null)
            url_ += "y=" + encodeURIComponent("" + y) + "&";
        if (webp !== undefined && webp !== null)
            url_ += "webp=" + encodeURIComponent("" + webp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class LanguagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getLanguages(pageNumber?: number | undefined, pageSize?: number | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfLanguageDto> {
        let url_ = this.baseUrl + "/api/v1/public/languages?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLanguages(_response);
        });
    }

    protected processGetLanguages(response: Response): Promise<PaginatedListOfLanguageDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfLanguageDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfLanguageDto>(null as any);
    }
}

export class ParticipantsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    participate(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/participants/participate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParticipate(_response);
        });
    }

    protected processParticipate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class QuestionnairesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getQuestionnaires(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, projectIds?: string[] | null | undefined, instantiationModes?: QuestionnaireInstantiationMode[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfQuestionnaireDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (instantiationModes !== undefined && instantiationModes !== null)
            instantiationModes && instantiationModes.forEach(item => { url_ += "instantiationModes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestionnaires(_response);
        });
    }

    protected processGetQuestionnaires(response: Response): Promise<PaginatedListOfQuestionnaireDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfQuestionnaireDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfQuestionnaireDto>(null as any);
    }

    getQuestionnaire(questionnaireId: string, signal?: AbortSignal): Promise<QuestionnaireDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestionnaire(_response);
        });
    }

    protected processGetQuestionnaire(response: Response): Promise<QuestionnaireDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuestionnaireDetailsDto>(null as any);
    }

    getQuestionnaireInstances(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, from?: Date | null | undefined, until?: Date | null | undefined, projectIds?: string[] | null | undefined, questionnaireIds?: string[] | null | undefined, states?: QuestionnaireInstanceState[] | null | undefined, showHidden?: boolean | undefined, signal?: AbortSignal): Promise<PaginatedListOfQuestionnaireInstanceDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/instances?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (until !== undefined && until !== null)
            url_ += "until=" + encodeURIComponent(until ? "" + until.toISOString() : "") + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (questionnaireIds !== undefined && questionnaireIds !== null)
            questionnaireIds && questionnaireIds.forEach(item => { url_ += "questionnaireIds=" + encodeURIComponent("" + item) + "&"; });
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (showHidden === null)
            throw new Error("The parameter 'showHidden' cannot be null.");
        else if (showHidden !== undefined)
            url_ += "showHidden=" + encodeURIComponent("" + showHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestionnaireInstances(_response);
        });
    }

    protected processGetQuestionnaireInstances(response: Response): Promise<PaginatedListOfQuestionnaireInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfQuestionnaireInstanceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfQuestionnaireInstanceDto>(null as any);
    }

    createQuestionnaireInstance(questionnaireId: string, signal?: AbortSignal): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/instances";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateQuestionnaireInstance(_response);
        });
    }

    protected processCreateQuestionnaireInstance(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getQuestionnaireInstance(questionnaireId: string, questionnaireInstanceId: string, signal?: AbortSignal): Promise<QuestionnaireInstanceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/instances/{questionnaireInstanceId}";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (questionnaireInstanceId === undefined || questionnaireInstanceId === null)
            throw new Error("The parameter 'questionnaireInstanceId' must be defined.");
        url_ = url_.replace("{questionnaireInstanceId}", encodeURIComponent("" + questionnaireInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuestionnaireInstance(_response);
        });
    }

    protected processGetQuestionnaireInstance(response: Response): Promise<QuestionnaireInstanceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireInstanceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuestionnaireInstanceDetailsDto>(null as any);
    }

    updateQuestionnaireInstance(questionnaireId: string, questionnaireInstanceId: string, command: UpdateQuestionnaireInstanceCommand, signal?: AbortSignal): Promise<QuestionnaireInstanceDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/instances/{questionnaireInstanceId}";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (questionnaireInstanceId === undefined || questionnaireInstanceId === null)
            throw new Error("The parameter 'questionnaireInstanceId' must be defined.");
        url_ = url_.replace("{questionnaireInstanceId}", encodeURIComponent("" + questionnaireInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQuestionnaireInstance(_response);
        });
    }

    protected processUpdateQuestionnaireInstance(response: Response): Promise<QuestionnaireInstanceDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionnaireInstanceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuestionnaireInstanceDetailsDto>(null as any);
    }

    generateQuestionnaireShareQrCode(contextObjectId: string, sharingOptionId: string, appId: string, questionnaireId: string, signal?: AbortSignal): Promise<QrCodeDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/generate-share-qr-code?";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined and cannot be null.");
        else
            url_ += "contextObjectId=" + encodeURIComponent("" + contextObjectId) + "&";
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined and cannot be null.");
        else
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateQuestionnaireShareQrCode(_response);
        });
    }

    protected processGenerateQuestionnaireShareQrCode(response: Response): Promise<QrCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QrCodeDto>(null as any);
    }

    useQuestionnaireShareQrCode(contextObjectId: string, sharingOptionId: string, sharedById: string, token: string, questionnaireId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/use-share-qr-code?";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined and cannot be null.");
        else
            url_ += "contextObjectId=" + encodeURIComponent("" + contextObjectId) + "&";
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (sharedById === undefined || sharedById === null)
            throw new Error("The parameter 'sharedById' must be defined and cannot be null.");
        else
            url_ += "sharedById=" + encodeURIComponent("" + sharedById) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUseQuestionnaireShareQrCode(_response);
        });
    }

    protected processUseQuestionnaireShareQrCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    generateQuestionnaireInstanceShareQrCode(contextObjectId: string, contextObjectInstanceId: string, sharingOptionId: string, appId: string, questionnaireId: string, questionnaireInstanceId: string, signal?: AbortSignal): Promise<QrCodeDto> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/instances/{questionnaireInstanceId}/generate-share-qr-code?";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (questionnaireInstanceId === undefined || questionnaireInstanceId === null)
            throw new Error("The parameter 'questionnaireInstanceId' must be defined.");
        url_ = url_.replace("{questionnaireInstanceId}", encodeURIComponent("" + questionnaireInstanceId));
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined and cannot be null.");
        else
            url_ += "contextObjectId=" + encodeURIComponent("" + contextObjectId) + "&";
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined and cannot be null.");
        else
            url_ += "contextObjectInstanceId=" + encodeURIComponent("" + contextObjectInstanceId) + "&";
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined and cannot be null.");
        else
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateQuestionnaireInstanceShareQrCode(_response);
        });
    }

    protected processGenerateQuestionnaireInstanceShareQrCode(response: Response): Promise<QrCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QrCodeDto>(null as any);
    }

    useQuestionnaireInstanceShareQrCode(contextObjectId: string, contextObjectInstanceId: string, sharingOptionId: string, sharedById: string, token: string, questionnaireId: string, questionnaireInstanceId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/questionnaires/{questionnaireId}/instances/{questionnaireInstanceId}/use-share-qr-code?";
        if (questionnaireId === undefined || questionnaireId === null)
            throw new Error("The parameter 'questionnaireId' must be defined.");
        url_ = url_.replace("{questionnaireId}", encodeURIComponent("" + questionnaireId));
        if (questionnaireInstanceId === undefined || questionnaireInstanceId === null)
            throw new Error("The parameter 'questionnaireInstanceId' must be defined.");
        url_ = url_.replace("{questionnaireInstanceId}", encodeURIComponent("" + questionnaireInstanceId));
        if (contextObjectId === undefined || contextObjectId === null)
            throw new Error("The parameter 'contextObjectId' must be defined and cannot be null.");
        else
            url_ += "contextObjectId=" + encodeURIComponent("" + contextObjectId) + "&";
        if (contextObjectInstanceId === undefined || contextObjectInstanceId === null)
            throw new Error("The parameter 'contextObjectInstanceId' must be defined and cannot be null.");
        else
            url_ += "contextObjectInstanceId=" + encodeURIComponent("" + contextObjectInstanceId) + "&";
        if (sharingOptionId === undefined || sharingOptionId === null)
            throw new Error("The parameter 'sharingOptionId' must be defined and cannot be null.");
        else
            url_ += "sharingOptionId=" + encodeURIComponent("" + sharingOptionId) + "&";
        if (sharedById === undefined || sharedById === null)
            throw new Error("The parameter 'sharedById' must be defined and cannot be null.");
        else
            url_ += "sharedById=" + encodeURIComponent("" + sharedById) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUseQuestionnaireInstanceShareQrCode(_response);
        });
    }

    protected processUseQuestionnaireInstanceShareQrCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    search(pageNumber?: number | undefined, pageSize?: number | undefined, search?: string | null | undefined, projectIds?: string[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfSearchResultDto> {
        let url_ = this.baseUrl + "/api/v1/public/search?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PaginatedListOfSearchResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSearchResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfSearchResultDto>(null as any);
    }

    wordSuggestions(limit?: number | undefined, search?: string | null | undefined, projectIds?: string[] | null | undefined, signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/public/search/word-suggestions?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectIds !== undefined && projectIds !== null)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWordSuggestions(_response);
        });
    }

    protected processWordSuggestions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class StudiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getStudies(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, states?: ProjectParticipationState[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfStudyDto> {
        let url_ = this.baseUrl + "/api/v1/public/studies?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStudies(_response);
        });
    }

    protected processGetStudies(response: Response): Promise<PaginatedListOfStudyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfStudyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfStudyDto>(null as any);
    }

    getPublicStudies(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfStudyDto> {
        let url_ = this.baseUrl + "/api/v1/public/studies/public?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicStudies(_response);
        });
    }

    protected processGetPublicStudies(response: Response): Promise<PaginatedListOfStudyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfStudyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfStudyDto>(null as any);
    }

    getStudy(studyId: string, signal?: AbortSignal): Promise<StudyDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/studies/{studyId}";
        if (studyId === undefined || studyId === null)
            throw new Error("The parameter 'studyId' must be defined.");
        url_ = url_.replace("{studyId}", encodeURIComponent("" + studyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStudy(_response);
        });
    }

    protected processGetStudy(response: Response): Promise<StudyDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudyDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StudyDetailsDto>(null as any);
    }

    participate(studyId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/studies/{studyId}/participate";
        if (studyId === undefined || studyId === null)
            throw new Error("The parameter 'studyId' must be defined.");
        url_ = url_.replace("{studyId}", encodeURIComponent("" + studyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParticipate(_response);
        });
    }

    protected processParticipate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    joinParticipantGroup(groupId: string, token: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/studies/groups/{groupId}/use-join-qr-code";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinParticipantGroup(_response);
        });
    }

    protected processJoinParticipantGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    withdraw(studyId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/studies/{studyId}/withdraw";
        if (studyId === undefined || studyId === null)
            throw new Error("The parameter 'studyId' must be defined.");
        url_ = url_.replace("{studyId}", encodeURIComponent("" + studyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdraw(_response);
        });
    }

    protected processWithdraw(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TenantEntityDto implements ITenantEntityDto {
    id!: string;
    tenantId!: string;

    constructor(data?: ITenantEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): TenantEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): TenantEntityDto {
        const json = this.toJSON();
        let result = new TenantEntityDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEntityDto {
    id: string;
    tenantId: string;
}

export abstract class ContainerDto extends TenantEntityDto implements IContainerDto {
    created!: Date;
    lastModified!: Date;
    projectId?: string | undefined;
    name!: string;
    title!: InternationalizedString;
    condition?: ContainerCondition | undefined;
    languages!: LanguageDto[];
    sharingOptions!: ContainerSharingOption[];

    constructor(data?: IContainerDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.languages = [];
            this.sharingOptions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.condition = _data["condition"] ? ContainerCondition.fromJS(_data["condition"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            if (Array.isArray(_data["sharingOptions"])) {
                this.sharingOptions = [] as any;
                for (let item of _data["sharingOptions"])
                    this.sharingOptions!.push(ContainerSharingOption.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContainerDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContainerDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sharingOptions)) {
            data["sharingOptions"] = [];
            for (let item of this.sharingOptions)
                data["sharingOptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContainerDto {
        throw new Error("The abstract class 'ContainerDto' cannot be instantiated.");
    }
}

export interface IContainerDto extends ITenantEntityDto {
    created: Date;
    lastModified: Date;
    projectId?: string | undefined;
    name: string;
    title: InternationalizedString;
    condition?: ContainerCondition | undefined;
    languages: LanguageDto[];
    sharingOptions: ContainerSharingOption[];
}

export class AppPageDto extends ContainerDto implements IAppPageDto {
    description!: InternationalizedDocument;
    published?: Date | undefined;
    contents!: ContentDto[];
    parentId?: string | undefined;
    order!: number;
    children!: AppPageDto[];
    tags!: string[];
    asset?: AssetDto | undefined;

    constructor(data?: IAppPageDto) {
        super(data);
        if (!data) {
            this.description = new InternationalizedDocument();
            this.contents = [];
            this.children = [];
            this.tags = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"] ? InternationalizedDocument.fromJS(_data["description"]) : new InternationalizedDocument();
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ContentDto.fromJS(item));
            }
            this.parentId = _data["parentId"];
            this.order = _data["order"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(AppPageDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AppPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPageDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["order"] = this.order;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): AppPageDto {
        const json = this.toJSON();
        let result = new AppPageDto();
        result.init(json);
        return result;
    }
}

export interface IAppPageDto extends IContainerDto {
    description: InternationalizedDocument;
    published?: Date | undefined;
    contents: ContentDto[];
    parentId?: string | undefined;
    order: number;
    children: AppPageDto[];
    tags: string[];
    asset?: AssetDto | undefined;
}

export class InternationalizedDocument implements IInternationalizedDocument {
    translations!: { [key: string]: Node; };

    constructor(data?: IInternationalizedDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.translations = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? Node.fromJS(_data["translations"][key]) : new Node();
                }
            }
        }
    }

    static fromJS(data: any): InternationalizedDocument {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalizedDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }

    clone(): InternationalizedDocument {
        const json = this.toJSON();
        let result = new InternationalizedDocument();
        result.init(json);
        return result;
    }
}

export interface IInternationalizedDocument {
    translations: { [key: string]: Node; };
}

export class Node implements INode {
    type!: NodeType;
    attrs?: NodeAttribute | undefined;
    content?: Node[] | undefined;
    marks?: Mark[] | undefined;
    text?: string | undefined;

    constructor(data?: INode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.attrs = _data["attrs"] ? NodeAttribute.fromJS(_data["attrs"]) : <any>undefined;
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(Node.fromJS(item));
            }
            if (Array.isArray(_data["marks"])) {
                this.marks = [] as any;
                for (let item of _data["marks"])
                    this.marks!.push(Mark.fromJS(item));
            }
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): Node {
        data = typeof data === 'object' ? data : {};
        let result = new Node();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["attrs"] = this.attrs ? this.attrs.toJSON() : <any>undefined;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.marks)) {
            data["marks"] = [];
            for (let item of this.marks)
                data["marks"].push(item.toJSON());
        }
        data["text"] = this.text;
        return data;
    }

    clone(): Node {
        const json = this.toJSON();
        let result = new Node();
        result.init(json);
        return result;
    }
}

export interface INode {
    type: NodeType;
    attrs?: NodeAttribute | undefined;
    content?: Node[] | undefined;
    marks?: Mark[] | undefined;
    text?: string | undefined;
}

export enum NodeType {
    Blockquote = "blockquote",
    BulletList = "bulletList",
    Doc = "doc",
    HardBreak = "hardBreak",
    Heading = "heading",
    HorizontalRule = "horizontalRule",
    ListItem = "listItem",
    OrderedList = "orderedList",
    Paragraph = "paragraph",
    Table = "table",
    TableRow = "tableRow",
    TableHeader = "tableHeader",
    TableCell = "tableCell",
    Text = "text",
    Video = "video",
    Audio = "audio",
    Image = "image",
    Html = "html",
    Details = "details",
    DetailsSummary = "detailsSummary",
    DetailsContent = "detailsContent",
    Figure = "figure",
    Figcaption = "figcaption",
}

export class NodeAttribute implements INodeAttribute {
    display?: string | undefined;
    level?: number | undefined;
    textAlign?: string | undefined;
    colspan?: number | undefined;
    rowspan?: number | undefined;
    colwidth?: number | undefined;
    start?: number | undefined;
    assetId?: string | undefined;
    src?: string | undefined;
    alt?: string | undefined;
    title?: string | undefined;
    caption?: string | undefined;
    html?: string | undefined;

    constructor(data?: INodeAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display = _data["display"];
            this.level = _data["level"];
            this.textAlign = _data["textAlign"];
            this.colspan = _data["colspan"];
            this.rowspan = _data["rowspan"];
            this.colwidth = _data["colwidth"];
            this.start = _data["start"];
            this.assetId = _data["assetId"];
            this.src = _data["src"];
            this.alt = _data["alt"];
            this.title = _data["title"];
            this.caption = _data["caption"];
            this.html = _data["html"];
        }
    }

    static fromJS(data: any): NodeAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new NodeAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["display"] = this.display;
        data["level"] = this.level;
        data["textAlign"] = this.textAlign;
        data["colspan"] = this.colspan;
        data["rowspan"] = this.rowspan;
        data["colwidth"] = this.colwidth;
        data["start"] = this.start;
        data["assetId"] = this.assetId;
        data["src"] = this.src;
        data["alt"] = this.alt;
        data["title"] = this.title;
        data["caption"] = this.caption;
        data["html"] = this.html;
        return data;
    }

    clone(): NodeAttribute {
        const json = this.toJSON();
        let result = new NodeAttribute();
        result.init(json);
        return result;
    }
}

export interface INodeAttribute {
    display?: string | undefined;
    level?: number | undefined;
    textAlign?: string | undefined;
    colspan?: number | undefined;
    rowspan?: number | undefined;
    colwidth?: number | undefined;
    start?: number | undefined;
    assetId?: string | undefined;
    src?: string | undefined;
    alt?: string | undefined;
    title?: string | undefined;
    caption?: string | undefined;
    html?: string | undefined;
}

export class Mark implements IMark {
    type!: MarkType;
    attrs?: MarkAttribute | undefined;

    constructor(data?: IMark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.attrs = _data["attrs"] ? MarkAttribute.fromJS(_data["attrs"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Mark {
        data = typeof data === 'object' ? data : {};
        let result = new Mark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["attrs"] = this.attrs ? this.attrs.toJSON() : <any>undefined;
        return data;
    }

    clone(): Mark {
        const json = this.toJSON();
        let result = new Mark();
        result.init(json);
        return result;
    }
}

export interface IMark {
    type: MarkType;
    attrs?: MarkAttribute | undefined;
}

export enum MarkType {
    Bold = "bold",
    Italic = "italic",
    Link = "link",
    Strike = "strike",
    Subscript = "subscript",
    Superscript = "superscript",
    Underline = "underline",
    Reference = "reference",
}

export class MarkAttribute implements IMarkAttribute {
    target?: string | undefined;
    title?: string | undefined;
    class?: string | undefined;
    href?: string | undefined;
    fileId?: string | undefined;
    referenceId?: string | undefined;
    referenceType?: ReferenceType | undefined;

    constructor(data?: IMarkAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.target = _data["target"];
            this.title = _data["title"];
            this.class = _data["class"];
            this.href = _data["href"];
            this.fileId = _data["fileId"];
            this.referenceId = _data["referenceId"];
            this.referenceType = _data["referenceType"];
        }
    }

    static fromJS(data: any): MarkAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["target"] = this.target;
        data["title"] = this.title;
        data["class"] = this.class;
        data["href"] = this.href;
        data["fileId"] = this.fileId;
        data["referenceId"] = this.referenceId;
        data["referenceType"] = this.referenceType;
        return data;
    }

    clone(): MarkAttribute {
        const json = this.toJSON();
        let result = new MarkAttribute();
        result.init(json);
        return result;
    }
}

export interface IMarkAttribute {
    target?: string | undefined;
    title?: string | undefined;
    class?: string | undefined;
    href?: string | undefined;
    fileId?: string | undefined;
    referenceId?: string | undefined;
    referenceType?: ReferenceType | undefined;
}

export enum ReferenceType {
    Asset = "asset",
    Page = "page",
}

export abstract class ContentDto implements IContentDto {
    id!: string;
    name!: string;
    elementType!: ElementType;
    condition?: ContentCondition | undefined;

    protected _discriminator: string;

    constructor(data?: IContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ContentDto";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.elementType = _data["elementType"];
            this.condition = _data["condition"] ? ContentCondition.fromJS(_data["condition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "ContentGroupDto") {
            let result = new ContentGroupDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ContentPageDto") {
            let result = new ContentPageDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DisplayDto") {
            throw new Error("The abstract class 'DisplayDto' cannot be instantiated.");
        }
        if (data["$type"] === "ImageDisplayDto") {
            let result = new ImageDisplayDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextDisplayDto") {
            let result = new TextDisplayDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "RichTextDisplayDto") {
            let result = new RichTextDisplayDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "PropertyDto") {
            throw new Error("The abstract class 'PropertyDto' cannot be instantiated.");
        }
        if (data["$type"] === "TextPropertyDto") {
            let result = new TextPropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberPropertyDto") {
            let result = new NumberPropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DatePropertyDto") {
            let result = new DatePropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoicePropertyDto") {
            let result = new ChoicePropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "QuestionDto") {
            throw new Error("The abstract class 'QuestionDto' cannot be instantiated.");
        }
        if (data["$type"] === "LikertQuestionDto") {
            let result = new LikertQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "MatrixQuestionDto") {
            let result = new MatrixQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoiceQuestionDto") {
            let result = new ChoiceQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextQuestionDto") {
            let result = new TextQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberQuestionDto") {
            let result = new NumberQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateQuestionDto") {
            let result = new DateQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TimeQuestionDto") {
            let result = new TimeQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateTimeQuestionDto") {
            let result = new DateTimeQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "SliderQuestionDto") {
            let result = new SliderQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ContainerQuestionDto") {
            let result = new ContainerQuestionDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ContentDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["elementType"] = this.elementType;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        return data;
    }

    clone(): ContentDto {
        throw new Error("The abstract class 'ContentDto' cannot be instantiated.");
    }
}

export interface IContentDto {
    id: string;
    name: string;
    elementType: ElementType;
    condition?: ContentCondition | undefined;
}

export enum ElementType {
    None = "none",
    ContentGroup = "contentGroup",
    ContentPage = "contentPage",
    ChoiceQuestion = "choiceQuestion",
    DateQuestion = "dateQuestion",
    DateTimeQuestion = "dateTimeQuestion",
    LikertQuestion = "likertQuestion",
    MatrixQuestion = "matrixQuestion",
    NumberQuestion = "numberQuestion",
    SliderQuestion = "sliderQuestion",
    TextQuestion = "textQuestion",
    TimeQuestion = "timeQuestion",
    RichTextDisplay = "richTextDisplay",
    ImageDisplay = "imageDisplay",
    TextDisplay = "textDisplay",
    QuestionnaireReferenceDisplay = "questionnaireReferenceDisplay",
    DateProperty = "dateProperty",
    NumberProperty = "numberProperty",
    TextProperty = "textProperty",
    ChoiceProperty = "choiceProperty",
    ContainerQuestion = "containerQuestion",
}

export abstract class Condition implements ICondition {
    expression!: string;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expression = _data["expression"];
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Condition' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expression"] = this.expression;
        return data;
    }

    clone(): Condition {
        throw new Error("The abstract class 'Condition' cannot be instantiated.");
    }
}

export interface ICondition {
    expression: string;
}

export class ContentCondition extends Condition implements IContentCondition {

    constructor(data?: IContentCondition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContentCondition {
        const json = this.toJSON();
        let result = new ContentCondition();
        result.init(json);
        return result;
    }
}

export interface IContentCondition extends ICondition {
}

export class ContentGroupDto extends ContentDto implements IContentGroupDto {
    contents!: ContentDto[];

    constructor(data?: IContentGroupDto) {
        super(data);
        if (!data) {
            this.contents = [];
        }
        this._discriminator = "ContentGroupDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ContentDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContentGroupDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContentGroupDto {
        const json = this.toJSON();
        let result = new ContentGroupDto();
        result.init(json);
        return result;
    }
}

export interface IContentGroupDto extends IContentDto {
    contents: ContentDto[];
}

export class ContentPageDto extends ContentDto implements IContentPageDto {
    title!: InternationalizedString;
    contents!: ContentDto[];

    constructor(data?: IContentPageDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.contents = [];
        }
        this._discriminator = "ContentPageDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ContentDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPageDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContentPageDto {
        const json = this.toJSON();
        let result = new ContentPageDto();
        result.init(json);
        return result;
    }
}

export interface IContentPageDto extends IContentDto {
    title: InternationalizedString;
    contents: ContentDto[];
}

export class InternationalizedString implements IInternationalizedString {
    translations!: { [key: string]: string; };

    constructor(data?: IInternationalizedString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.translations = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key];
                }
            }
        }
    }

    static fromJS(data: any): InternationalizedString {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalizedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = (<any>this.translations)[key];
            }
        }
        return data;
    }

    clone(): InternationalizedString {
        const json = this.toJSON();
        let result = new InternationalizedString();
        result.init(json);
        return result;
    }
}

export interface IInternationalizedString {
    translations: { [key: string]: string; };
}

export abstract class DisplayDto extends ContentDto implements IDisplayDto {

    constructor(data?: IDisplayDto) {
        super(data);
        this._discriminator = "DisplayDto";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DisplayDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "ImageDisplayDto") {
            let result = new ImageDisplayDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextDisplayDto") {
            let result = new TextDisplayDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "RichTextDisplayDto") {
            let result = new RichTextDisplayDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DisplayDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): DisplayDto {
        throw new Error("The abstract class 'DisplayDto' cannot be instantiated.");
    }
}

export interface IDisplayDto extends IContentDto {
}

export class ImageDisplayDto extends DisplayDto implements IImageDisplayDto {
    assetId?: string | undefined;
    asset?: AssetDto | undefined;
    description!: InternationalizedString;
    accessibleDescription!: InternationalizedString;

    constructor(data?: IImageDisplayDto) {
        super(data);
        if (!data) {
            this.description = new InternationalizedString();
            this.accessibleDescription = new InternationalizedString();
        }
        this._discriminator = "ImageDisplayDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.assetId = _data["assetId"];
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            this.description = _data["description"] ? InternationalizedString.fromJS(_data["description"]) : new InternationalizedString();
            this.accessibleDescription = _data["accessibleDescription"] ? InternationalizedString.fromJS(_data["accessibleDescription"]) : new InternationalizedString();
        }
    }

    static override fromJS(data: any): ImageDisplayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageDisplayDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetId"] = this.assetId;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["accessibleDescription"] = this.accessibleDescription ? this.accessibleDescription.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ImageDisplayDto {
        const json = this.toJSON();
        let result = new ImageDisplayDto();
        result.init(json);
        return result;
    }
}

export interface IImageDisplayDto extends IDisplayDto {
    assetId?: string | undefined;
    asset?: AssetDto | undefined;
    description: InternationalizedString;
    accessibleDescription: InternationalizedString;
}

export class AssetDto extends TenantEntityDto implements IAssetDto {
    file?: FileDto | undefined;
    name!: string;
    description?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    x?: number | undefined;
    y?: number | undefined;
    contentType!: string;

    constructor(data?: IAssetDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.file = _data["file"] ? FileDto.fromJS(_data["file"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.contentType = _data["contentType"];
        }
    }

    static override fromJS(data: any): AssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["width"] = this.width;
        data["height"] = this.height;
        data["x"] = this.x;
        data["y"] = this.y;
        data["contentType"] = this.contentType;
        super.toJSON(data);
        return data;
    }

    clone(): AssetDto {
        const json = this.toJSON();
        let result = new AssetDto();
        result.init(json);
        return result;
    }
}

export interface IAssetDto extends ITenantEntityDto {
    file?: FileDto | undefined;
    name: string;
    description?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    x?: number | undefined;
    y?: number | undefined;
    contentType: string;
}

export class FileDto implements IFileDto {
    url?: string | undefined;
    id!: string;
    name!: string;
    created!: Date;
    lastModified!: Date;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    url?: string | undefined;
    id: string;
    name: string;
    created: Date;
    lastModified: Date;
}

export class TextDisplayDto extends DisplayDto implements ITextDisplayDto {
    value!: InternationalizedString;

    constructor(data?: ITextDisplayDto) {
        super(data);
        if (!data) {
            this.value = new InternationalizedString();
        }
        this._discriminator = "TextDisplayDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? InternationalizedString.fromJS(_data["value"]) : new InternationalizedString();
        }
    }

    static override fromJS(data: any): TextDisplayDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextDisplayDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): TextDisplayDto {
        const json = this.toJSON();
        let result = new TextDisplayDto();
        result.init(json);
        return result;
    }
}

export interface ITextDisplayDto extends IDisplayDto {
    value: InternationalizedString;
}

export class RichTextDisplayDto extends DisplayDto implements IRichTextDisplayDto {
    value!: InternationalizedDocument;

    constructor(data?: IRichTextDisplayDto) {
        super(data);
        if (!data) {
            this.value = new InternationalizedDocument();
        }
        this._discriminator = "RichTextDisplayDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? InternationalizedDocument.fromJS(_data["value"]) : new InternationalizedDocument();
        }
    }

    static override fromJS(data: any): RichTextDisplayDto {
        data = typeof data === 'object' ? data : {};
        let result = new RichTextDisplayDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): RichTextDisplayDto {
        const json = this.toJSON();
        let result = new RichTextDisplayDto();
        result.init(json);
        return result;
    }
}

export interface IRichTextDisplayDto extends IDisplayDto {
    value: InternationalizedDocument;
}

export abstract class PropertyDto extends ContentDto implements IPropertyDto {
    text!: InternationalizedString;

    constructor(data?: IPropertyDto) {
        super(data);
        if (!data) {
            this.text = new InternationalizedString();
        }
        this._discriminator = "PropertyDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.text = _data["text"] ? InternationalizedString.fromJS(_data["text"]) : new InternationalizedString();
        }
    }

    static override fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "TextPropertyDto") {
            let result = new TextPropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberPropertyDto") {
            let result = new NumberPropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DatePropertyDto") {
            let result = new DatePropertyDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoicePropertyDto") {
            let result = new ChoicePropertyDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'PropertyDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text ? this.text.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): PropertyDto {
        throw new Error("The abstract class 'PropertyDto' cannot be instantiated.");
    }
}

export interface IPropertyDto extends IContentDto {
    text: InternationalizedString;
}

export class TextPropertyDto extends PropertyDto implements ITextPropertyDto {
    validation!: TextPropertyValidation;
    multiline!: boolean;
    value?: TextValueDto | undefined;

    constructor(data?: ITextPropertyDto) {
        super(data);
        if (!data) {
            this.validation = new TextPropertyValidation();
        }
        this._discriminator = "TextPropertyDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? TextPropertyValidation.fromJS(_data["validation"]) : new TextPropertyValidation();
            this.multiline = _data["multiline"];
            this.value = _data["value"] ? TextValueDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TextPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextPropertyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["multiline"] = this.multiline;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): TextPropertyDto {
        const json = this.toJSON();
        let result = new TextPropertyDto();
        result.init(json);
        return result;
    }
}

export interface ITextPropertyDto extends IPropertyDto {
    validation: TextPropertyValidation;
    multiline: boolean;
    value?: TextValueDto | undefined;
}

export abstract class PropertyValidation implements IPropertyValidation {
    required!: boolean;

    protected _discriminator: string;

    constructor(data?: IPropertyValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PropertyValidation";
    }

    init(_data?: any) {
        if (_data) {
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): PropertyValidation {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "TextPropertyValidation") {
            let result = new TextPropertyValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DatePropertyValidation") {
            let result = new DatePropertyValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberPropertyValidation") {
            let result = new NumberPropertyValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoicePropertyValidation") {
            let result = new ChoicePropertyValidation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'PropertyValidation' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["required"] = this.required;
        return data;
    }

    clone(): PropertyValidation {
        throw new Error("The abstract class 'PropertyValidation' cannot be instantiated.");
    }
}

export interface IPropertyValidation {
    required: boolean;
}

export class TextPropertyValidation extends PropertyValidation implements ITextPropertyValidation {
    minLength?: number | undefined;
    maxLength?: number | undefined;
    pattern?: string | undefined;

    constructor(data?: ITextPropertyValidation) {
        super(data);
        this._discriminator = "TextPropertyValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minLength = _data["minLength"];
            this.maxLength = _data["maxLength"];
            this.pattern = _data["pattern"];
        }
    }

    static override fromJS(data: any): TextPropertyValidation {
        data = typeof data === 'object' ? data : {};
        let result = new TextPropertyValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["pattern"] = this.pattern;
        super.toJSON(data);
        return data;
    }

    clone(): TextPropertyValidation {
        const json = this.toJSON();
        let result = new TextPropertyValidation();
        result.init(json);
        return result;
    }
}

export interface ITextPropertyValidation extends IPropertyValidation {
    minLength?: number | undefined;
    maxLength?: number | undefined;
    pattern?: string | undefined;
}

export class DatePropertyValidation extends PropertyValidation implements IDatePropertyValidation {
    min?: Date | undefined;
    max?: Date | undefined;

    constructor(data?: IDatePropertyValidation) {
        super(data);
        this._discriminator = "DatePropertyValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"] ? new Date(_data["min"].toString()) : <any>undefined;
            this.max = _data["max"] ? new Date(_data["max"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DatePropertyValidation {
        data = typeof data === 'object' ? data : {};
        let result = new DatePropertyValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min ? formatDate(this.min) : <any>undefined;
        data["max"] = this.max ? formatDate(this.max) : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DatePropertyValidation {
        const json = this.toJSON();
        let result = new DatePropertyValidation();
        result.init(json);
        return result;
    }
}

export interface IDatePropertyValidation extends IPropertyValidation {
    min?: Date | undefined;
    max?: Date | undefined;
}

export class NumberPropertyValidation extends PropertyValidation implements INumberPropertyValidation {
    min?: number | undefined;
    max?: number | undefined;
    fraction!: boolean;

    constructor(data?: INumberPropertyValidation) {
        super(data);
        this._discriminator = "NumberPropertyValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
            this.fraction = _data["fraction"];
        }
    }

    static override fromJS(data: any): NumberPropertyValidation {
        data = typeof data === 'object' ? data : {};
        let result = new NumberPropertyValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        data["fraction"] = this.fraction;
        super.toJSON(data);
        return data;
    }

    clone(): NumberPropertyValidation {
        const json = this.toJSON();
        let result = new NumberPropertyValidation();
        result.init(json);
        return result;
    }
}

export interface INumberPropertyValidation extends IPropertyValidation {
    min?: number | undefined;
    max?: number | undefined;
    fraction: boolean;
}

export class ChoicePropertyValidation extends PropertyValidation implements IChoicePropertyValidation {

    constructor(data?: IChoicePropertyValidation) {
        super(data);
        this._discriminator = "ChoicePropertyValidation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChoicePropertyValidation {
        data = typeof data === 'object' ? data : {};
        let result = new ChoicePropertyValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ChoicePropertyValidation {
        const json = this.toJSON();
        let result = new ChoicePropertyValidation();
        result.init(json);
        return result;
    }
}

export interface IChoicePropertyValidation extends IPropertyValidation {
}

export abstract class ValueDto implements IValueDto {
    propertyId!: string;

    protected _discriminator: string;

    constructor(data?: IValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ValueDto";
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): ValueDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "TextValueDto") {
            let result = new TextValueDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateValueDto") {
            let result = new DateValueDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberValueDto") {
            let result = new NumberValueDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoiceValueDto") {
            let result = new ChoiceValueDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ValueDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["propertyId"] = this.propertyId;
        return data;
    }

    clone(): ValueDto {
        throw new Error("The abstract class 'ValueDto' cannot be instantiated.");
    }
}

export interface IValueDto {
    propertyId: string;
}

export class TextValueDto extends ValueDto implements ITextValueDto {
    value?: string | undefined;

    constructor(data?: ITextValueDto) {
        super(data);
        this._discriminator = "TextValueDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): TextValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextValueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): TextValueDto {
        const json = this.toJSON();
        let result = new TextValueDto();
        result.init(json);
        return result;
    }
}

export interface ITextValueDto extends IValueDto {
    value?: string | undefined;
}

export class DateValueDto extends ValueDto implements IDateValueDto {
    value?: Date | undefined;

    constructor(data?: IDateValueDto) {
        super(data);
        this._discriminator = "DateValueDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateValueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? formatDate(this.value) : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateValueDto {
        const json = this.toJSON();
        let result = new DateValueDto();
        result.init(json);
        return result;
    }
}

export interface IDateValueDto extends IValueDto {
    value?: Date | undefined;
}

export class NumberValueDto extends ValueDto implements INumberValueDto {
    value?: number | undefined;

    constructor(data?: INumberValueDto) {
        super(data);
        this._discriminator = "NumberValueDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): NumberValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NumberValueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): NumberValueDto {
        const json = this.toJSON();
        let result = new NumberValueDto();
        result.init(json);
        return result;
    }
}

export interface INumberValueDto extends IValueDto {
    value?: number | undefined;
}

export class ChoiceValueDto extends ValueDto implements IChoiceValueDto {
    values?: string[] | undefined;

    constructor(data?: IChoiceValueDto) {
        super(data);
        this._discriminator = "ChoiceValueDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static override fromJS(data: any): ChoiceValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoiceValueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        super.toJSON(data);
        return data;
    }

    clone(): ChoiceValueDto {
        const json = this.toJSON();
        let result = new ChoiceValueDto();
        result.init(json);
        return result;
    }
}

export interface IChoiceValueDto extends IValueDto {
    values?: string[] | undefined;
}

export class NumberPropertyDto extends PropertyDto implements INumberPropertyDto {
    validation!: NumberPropertyValidation;
    value?: NumberValueDto | undefined;

    constructor(data?: INumberPropertyDto) {
        super(data);
        if (!data) {
            this.validation = new NumberPropertyValidation();
        }
        this._discriminator = "NumberPropertyDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? NumberPropertyValidation.fromJS(_data["validation"]) : new NumberPropertyValidation();
            this.value = _data["value"] ? NumberValueDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): NumberPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new NumberPropertyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): NumberPropertyDto {
        const json = this.toJSON();
        let result = new NumberPropertyDto();
        result.init(json);
        return result;
    }
}

export interface INumberPropertyDto extends IPropertyDto {
    validation: NumberPropertyValidation;
    value?: NumberValueDto | undefined;
}

export class DatePropertyDto extends PropertyDto implements IDatePropertyDto {
    validation!: DatePropertyValidation;
    value?: DateValueDto | undefined;

    constructor(data?: IDatePropertyDto) {
        super(data);
        if (!data) {
            this.validation = new DatePropertyValidation();
        }
        this._discriminator = "DatePropertyDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? DatePropertyValidation.fromJS(_data["validation"]) : new DatePropertyValidation();
            this.value = _data["value"] ? DateValueDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DatePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DatePropertyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DatePropertyDto {
        const json = this.toJSON();
        let result = new DatePropertyDto();
        result.init(json);
        return result;
    }
}

export interface IDatePropertyDto extends IPropertyDto {
    validation: DatePropertyValidation;
    value?: DateValueDto | undefined;
}

export class ChoicePropertyDto extends PropertyDto implements IChoicePropertyDto {
    validation!: ChoicePropertyValidation;
    multiSelection!: boolean;
    choices!: SelectionItem[];
    value?: ChoiceValueDto | undefined;

    constructor(data?: IChoicePropertyDto) {
        super(data);
        if (!data) {
            this.validation = new ChoicePropertyValidation();
            this.choices = [];
        }
        this._discriminator = "ChoicePropertyDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? ChoicePropertyValidation.fromJS(_data["validation"]) : new ChoicePropertyValidation();
            this.multiSelection = _data["multiSelection"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(SelectionItem.fromJS(item));
            }
            this.value = _data["value"] ? ChoiceValueDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChoicePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoicePropertyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["multiSelection"] = this.multiSelection;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ChoicePropertyDto {
        const json = this.toJSON();
        let result = new ChoicePropertyDto();
        result.init(json);
        return result;
    }
}

export interface IChoicePropertyDto extends IPropertyDto {
    validation: ChoicePropertyValidation;
    multiSelection: boolean;
    choices: SelectionItem[];
    value?: ChoiceValueDto | undefined;
}

export class SelectionItem implements ISelectionItem {
    id!: string;
    value!: string;
    label!: InternationalizedString;

    constructor(data?: ISelectionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new InternationalizedString();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.label = _data["label"] ? InternationalizedString.fromJS(_data["label"]) : new InternationalizedString();
        }
    }

    static fromJS(data: any): SelectionItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        return data;
    }

    clone(): SelectionItem {
        const json = this.toJSON();
        let result = new SelectionItem();
        result.init(json);
        return result;
    }
}

export interface ISelectionItem {
    id: string;
    value: string;
    label: InternationalizedString;
}

export abstract class QuestionDto extends ContentDto implements IQuestionDto {
    text!: InternationalizedString;
    hint?: InternationalizedDocument | undefined;

    constructor(data?: IQuestionDto) {
        super(data);
        if (!data) {
            this.text = new InternationalizedString();
        }
        this._discriminator = "QuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.text = _data["text"] ? InternationalizedString.fromJS(_data["text"]) : new InternationalizedString();
            this.hint = _data["hint"] ? InternationalizedDocument.fromJS(_data["hint"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "LikertQuestionDto") {
            let result = new LikertQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "MatrixQuestionDto") {
            let result = new MatrixQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoiceQuestionDto") {
            let result = new ChoiceQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextQuestionDto") {
            let result = new TextQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberQuestionDto") {
            let result = new NumberQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateQuestionDto") {
            let result = new DateQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TimeQuestionDto") {
            let result = new TimeQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateTimeQuestionDto") {
            let result = new DateTimeQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "SliderQuestionDto") {
            let result = new SliderQuestionDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ContainerQuestionDto") {
            let result = new ContainerQuestionDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'QuestionDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text ? this.text.toJSON() : <any>undefined;
        data["hint"] = this.hint ? this.hint.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionDto {
        throw new Error("The abstract class 'QuestionDto' cannot be instantiated.");
    }
}

export interface IQuestionDto extends IContentDto {
    text: InternationalizedString;
    hint?: InternationalizedDocument | undefined;
}

export class LikertQuestionDto extends QuestionDto implements ILikertQuestionDto {
    validation!: LikertQuestionValidation;
    scale!: LikertScaleItem[];
    answer?: LikertAnswerDto | undefined;

    constructor(data?: ILikertQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new LikertQuestionValidation();
            this.scale = [];
        }
        this._discriminator = "LikertQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? LikertQuestionValidation.fromJS(_data["validation"]) : new LikertQuestionValidation();
            if (Array.isArray(_data["scale"])) {
                this.scale = [] as any;
                for (let item of _data["scale"])
                    this.scale!.push(LikertScaleItem.fromJS(item));
            }
            this.answer = _data["answer"] ? LikertAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): LikertQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikertQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        if (Array.isArray(this.scale)) {
            data["scale"] = [];
            for (let item of this.scale)
                data["scale"].push(item.toJSON());
        }
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): LikertQuestionDto {
        const json = this.toJSON();
        let result = new LikertQuestionDto();
        result.init(json);
        return result;
    }
}

export interface ILikertQuestionDto extends IQuestionDto {
    validation: LikertQuestionValidation;
    scale: LikertScaleItem[];
    answer?: LikertAnswerDto | undefined;
}

export abstract class QuestionValidation implements IQuestionValidation {
    required!: boolean;

    protected _discriminator: string;

    constructor(data?: IQuestionValidation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "QuestionValidation";
    }

    init(_data?: any) {
        if (_data) {
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): QuestionValidation {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "LikertQuestionValidation") {
            let result = new LikertQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoiceQuestionValidation") {
            let result = new ChoiceQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateQuestionValidation") {
            let result = new DateQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateTimeQuestionValidation") {
            let result = new DateTimeQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "MatrixQuestionValidation") {
            let result = new MatrixQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberQuestionValidation") {
            let result = new NumberQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "SliderQuestionValidation") {
            let result = new SliderQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextQuestionValidation") {
            let result = new TextQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TimeQuestionValidation") {
            let result = new TimeQuestionValidation();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ContainerQuestionValidation") {
            let result = new ContainerQuestionValidation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'QuestionValidation' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["required"] = this.required;
        return data;
    }

    clone(): QuestionValidation {
        throw new Error("The abstract class 'QuestionValidation' cannot be instantiated.");
    }
}

export interface IQuestionValidation {
    required: boolean;
}

export class LikertQuestionValidation extends QuestionValidation implements ILikertQuestionValidation {

    constructor(data?: ILikertQuestionValidation) {
        super(data);
        this._discriminator = "LikertQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): LikertQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new LikertQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): LikertQuestionValidation {
        const json = this.toJSON();
        let result = new LikertQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface ILikertQuestionValidation extends IQuestionValidation {
}

export class ChoiceQuestionValidation extends QuestionValidation implements IChoiceQuestionValidation {

    constructor(data?: IChoiceQuestionValidation) {
        super(data);
        this._discriminator = "ChoiceQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChoiceQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new ChoiceQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ChoiceQuestionValidation {
        const json = this.toJSON();
        let result = new ChoiceQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface IChoiceQuestionValidation extends IQuestionValidation {
}

export class DateQuestionValidation extends QuestionValidation implements IDateQuestionValidation {
    min?: Date | undefined;
    max?: Date | undefined;

    constructor(data?: IDateQuestionValidation) {
        super(data);
        this._discriminator = "DateQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"] ? new Date(_data["min"].toString()) : <any>undefined;
            this.max = _data["max"] ? new Date(_data["max"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new DateQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min ? formatDate(this.min) : <any>undefined;
        data["max"] = this.max ? formatDate(this.max) : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateQuestionValidation {
        const json = this.toJSON();
        let result = new DateQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface IDateQuestionValidation extends IQuestionValidation {
    min?: Date | undefined;
    max?: Date | undefined;
}

export class DateTimeQuestionValidation extends QuestionValidation implements IDateTimeQuestionValidation {
    min?: Date | undefined;
    max?: Date | undefined;

    constructor(data?: IDateTimeQuestionValidation) {
        super(data);
        this._discriminator = "DateTimeQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"] ? new Date(_data["min"].toString()) : <any>undefined;
            this.max = _data["max"] ? new Date(_data["max"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateTimeQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min ? this.min.toISOString() : <any>undefined;
        data["max"] = this.max ? this.max.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateTimeQuestionValidation {
        const json = this.toJSON();
        let result = new DateTimeQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface IDateTimeQuestionValidation extends IQuestionValidation {
    min?: Date | undefined;
    max?: Date | undefined;
}

export class MatrixQuestionValidation extends QuestionValidation implements IMatrixQuestionValidation {

    constructor(data?: IMatrixQuestionValidation) {
        super(data);
        this._discriminator = "MatrixQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MatrixQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new MatrixQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): MatrixQuestionValidation {
        const json = this.toJSON();
        let result = new MatrixQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface IMatrixQuestionValidation extends IQuestionValidation {
}

export class NumberQuestionValidation extends QuestionValidation implements INumberQuestionValidation {
    min?: number | undefined;
    max?: number | undefined;
    fraction!: boolean;

    constructor(data?: INumberQuestionValidation) {
        super(data);
        this._discriminator = "NumberQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
            this.fraction = _data["fraction"];
        }
    }

    static override fromJS(data: any): NumberQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new NumberQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        data["fraction"] = this.fraction;
        super.toJSON(data);
        return data;
    }

    clone(): NumberQuestionValidation {
        const json = this.toJSON();
        let result = new NumberQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface INumberQuestionValidation extends IQuestionValidation {
    min?: number | undefined;
    max?: number | undefined;
    fraction: boolean;
}

export class SliderQuestionValidation extends QuestionValidation implements ISliderQuestionValidation {
    min!: number;
    max!: number;

    constructor(data?: ISliderQuestionValidation) {
        super(data);
        this._discriminator = "SliderQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static override fromJS(data: any): SliderQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new SliderQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        super.toJSON(data);
        return data;
    }

    clone(): SliderQuestionValidation {
        const json = this.toJSON();
        let result = new SliderQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface ISliderQuestionValidation extends IQuestionValidation {
    min: number;
    max: number;
}

export class TextQuestionValidation extends QuestionValidation implements ITextQuestionValidation {
    minLength?: number | undefined;
    maxLength?: number | undefined;
    pattern?: string | undefined;

    constructor(data?: ITextQuestionValidation) {
        super(data);
        this._discriminator = "TextQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minLength = _data["minLength"];
            this.maxLength = _data["maxLength"];
            this.pattern = _data["pattern"];
        }
    }

    static override fromJS(data: any): TextQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new TextQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["pattern"] = this.pattern;
        super.toJSON(data);
        return data;
    }

    clone(): TextQuestionValidation {
        const json = this.toJSON();
        let result = new TextQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface ITextQuestionValidation extends IQuestionValidation {
    minLength?: number | undefined;
    maxLength?: number | undefined;
    pattern?: string | undefined;
}

export class TimeQuestionValidation extends QuestionValidation implements ITimeQuestionValidation {
    min?: string | undefined;
    max?: string | undefined;

    constructor(data?: ITimeQuestionValidation) {
        super(data);
        this._discriminator = "TimeQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static override fromJS(data: any): TimeQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new TimeQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        super.toJSON(data);
        return data;
    }

    clone(): TimeQuestionValidation {
        const json = this.toJSON();
        let result = new TimeQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface ITimeQuestionValidation extends IQuestionValidation {
    min?: string | undefined;
    max?: string | undefined;
}

export class ContainerQuestionValidation extends QuestionValidation implements IContainerQuestionValidation {

    constructor(data?: IContainerQuestionValidation) {
        super(data);
        this._discriminator = "ContainerQuestionValidation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContainerQuestionValidation {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerQuestionValidation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContainerQuestionValidation {
        const json = this.toJSON();
        let result = new ContainerQuestionValidation();
        result.init(json);
        return result;
    }
}

export interface IContainerQuestionValidation extends IQuestionValidation {
}

export class LikertScaleItem implements ILikertScaleItem {
    id!: string;
    value!: string;
    label!: InternationalizedString;

    constructor(data?: ILikertScaleItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new InternationalizedString();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.label = _data["label"] ? InternationalizedString.fromJS(_data["label"]) : new InternationalizedString();
        }
    }

    static fromJS(data: any): LikertScaleItem {
        data = typeof data === 'object' ? data : {};
        let result = new LikertScaleItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        return data;
    }

    clone(): LikertScaleItem {
        const json = this.toJSON();
        let result = new LikertScaleItem();
        result.init(json);
        return result;
    }
}

export interface ILikertScaleItem {
    id: string;
    value: string;
    label: InternationalizedString;
}

export abstract class AnswerDto implements IAnswerDto {
    questionId!: string;
    answered?: Date | undefined;

    protected _discriminator: string;

    constructor(data?: IAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnswerDto";
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.answered = _data["answered"] ? new Date(_data["answered"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AnswerDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "LikertAnswerDto") {
            let result = new LikertAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ChoiceAnswerDto") {
            let result = new ChoiceAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateAnswerDto") {
            let result = new DateAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "DateTimeAnswerDto") {
            let result = new DateTimeAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "MatrixAnswerDto") {
            let result = new MatrixAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "NumberAnswerDto") {
            let result = new NumberAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "SliderAnswerDto") {
            let result = new SliderAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TextAnswerDto") {
            let result = new TextAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "TimeAnswerDto") {
            let result = new TimeAnswerDto();
            result.init(data);
            return result;
        }
        if (data["$type"] === "ContainerAnswerDto") {
            let result = new ContainerAnswerDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AnswerDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["questionId"] = this.questionId;
        data["answered"] = this.answered ? this.answered.toISOString() : <any>undefined;
        return data;
    }

    clone(): AnswerDto {
        throw new Error("The abstract class 'AnswerDto' cannot be instantiated.");
    }
}

export interface IAnswerDto {
    questionId: string;
    answered?: Date | undefined;
}

export class LikertAnswerDto extends AnswerDto implements ILikertAnswerDto {
    value?: string | undefined;

    constructor(data?: ILikertAnswerDto) {
        super(data);
        this._discriminator = "LikertAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): LikertAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikertAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): LikertAnswerDto {
        const json = this.toJSON();
        let result = new LikertAnswerDto();
        result.init(json);
        return result;
    }
}

export interface ILikertAnswerDto extends IAnswerDto {
    value?: string | undefined;
}

export class ChoiceAnswerDto extends AnswerDto implements IChoiceAnswerDto {
    values?: string[] | undefined;

    constructor(data?: IChoiceAnswerDto) {
        super(data);
        this._discriminator = "ChoiceAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static override fromJS(data: any): ChoiceAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoiceAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        super.toJSON(data);
        return data;
    }

    clone(): ChoiceAnswerDto {
        const json = this.toJSON();
        let result = new ChoiceAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IChoiceAnswerDto extends IAnswerDto {
    values?: string[] | undefined;
}

export class DateAnswerDto extends AnswerDto implements IDateAnswerDto {
    value?: Date | undefined;

    constructor(data?: IDateAnswerDto) {
        super(data);
        this._discriminator = "DateAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? formatDate(this.value) : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateAnswerDto {
        const json = this.toJSON();
        let result = new DateAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IDateAnswerDto extends IAnswerDto {
    value?: Date | undefined;
}

export class DateTimeAnswerDto extends AnswerDto implements IDateTimeAnswerDto {
    value?: Date | undefined;

    constructor(data?: IDateTimeAnswerDto) {
        super(data);
        this._discriminator = "DateTimeAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateTimeAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateTimeAnswerDto {
        const json = this.toJSON();
        let result = new DateTimeAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IDateTimeAnswerDto extends IAnswerDto {
    value?: Date | undefined;
}

export class MatrixAnswerDto extends AnswerDto implements IMatrixAnswerDto {
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IMatrixAnswerDto) {
        super(data);
        this._discriminator = "MatrixAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static override fromJS(data: any): MatrixAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatrixAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        super.toJSON(data);
        return data;
    }

    clone(): MatrixAnswerDto {
        const json = this.toJSON();
        let result = new MatrixAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IMatrixAnswerDto extends IAnswerDto {
    values?: { [key: string]: string; } | undefined;
}

export class NumberAnswerDto extends AnswerDto implements INumberAnswerDto {
    value?: number | undefined;

    constructor(data?: INumberAnswerDto) {
        super(data);
        this._discriminator = "NumberAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): NumberAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new NumberAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): NumberAnswerDto {
        const json = this.toJSON();
        let result = new NumberAnswerDto();
        result.init(json);
        return result;
    }
}

export interface INumberAnswerDto extends IAnswerDto {
    value?: number | undefined;
}

export class SliderAnswerDto extends AnswerDto implements ISliderAnswerDto {
    value?: number | undefined;

    constructor(data?: ISliderAnswerDto) {
        super(data);
        this._discriminator = "SliderAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): SliderAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SliderAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): SliderAnswerDto {
        const json = this.toJSON();
        let result = new SliderAnswerDto();
        result.init(json);
        return result;
    }
}

export interface ISliderAnswerDto extends IAnswerDto {
    value?: number | undefined;
}

export class TextAnswerDto extends AnswerDto implements ITextAnswerDto {
    value?: string | undefined;

    constructor(data?: ITextAnswerDto) {
        super(data);
        this._discriminator = "TextAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): TextAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): TextAnswerDto {
        const json = this.toJSON();
        let result = new TextAnswerDto();
        result.init(json);
        return result;
    }
}

export interface ITextAnswerDto extends IAnswerDto {
    value?: string | undefined;
}

export class TimeAnswerDto extends AnswerDto implements ITimeAnswerDto {
    value?: string | undefined;

    constructor(data?: ITimeAnswerDto) {
        super(data);
        this._discriminator = "TimeAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): TimeAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }

    clone(): TimeAnswerDto {
        const json = this.toJSON();
        let result = new TimeAnswerDto();
        result.init(json);
        return result;
    }
}

export interface ITimeAnswerDto extends IAnswerDto {
    value?: string | undefined;
}

export class ContainerAnswerDto extends AnswerDto implements IContainerAnswerDto {
    values?: string[] | undefined;

    constructor(data?: IContainerAnswerDto) {
        super(data);
        this._discriminator = "ContainerAnswerDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContainerAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerAnswerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContainerAnswerDto {
        const json = this.toJSON();
        let result = new ContainerAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IContainerAnswerDto extends IAnswerDto {
    values?: string[] | undefined;
}

export class MatrixQuestionDto extends QuestionDto implements IMatrixQuestionDto {
    validation!: MatrixQuestionValidation;
    xScale!: SelectionItem[];
    yScale!: SelectionItem[];
    answer?: MatrixAnswerDto | undefined;

    constructor(data?: IMatrixQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new MatrixQuestionValidation();
            this.xScale = [];
            this.yScale = [];
        }
        this._discriminator = "MatrixQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? MatrixQuestionValidation.fromJS(_data["validation"]) : new MatrixQuestionValidation();
            if (Array.isArray(_data["xScale"])) {
                this.xScale = [] as any;
                for (let item of _data["xScale"])
                    this.xScale!.push(SelectionItem.fromJS(item));
            }
            if (Array.isArray(_data["yScale"])) {
                this.yScale = [] as any;
                for (let item of _data["yScale"])
                    this.yScale!.push(SelectionItem.fromJS(item));
            }
            this.answer = _data["answer"] ? MatrixAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): MatrixQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatrixQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        if (Array.isArray(this.xScale)) {
            data["xScale"] = [];
            for (let item of this.xScale)
                data["xScale"].push(item.toJSON());
        }
        if (Array.isArray(this.yScale)) {
            data["yScale"] = [];
            for (let item of this.yScale)
                data["yScale"].push(item.toJSON());
        }
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): MatrixQuestionDto {
        const json = this.toJSON();
        let result = new MatrixQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IMatrixQuestionDto extends IQuestionDto {
    validation: MatrixQuestionValidation;
    xScale: SelectionItem[];
    yScale: SelectionItem[];
    answer?: MatrixAnswerDto | undefined;
}

export class ChoiceQuestionDto extends QuestionDto implements IChoiceQuestionDto {
    validation!: ChoiceQuestionValidation;
    multiSelection!: boolean;
    choices!: SelectionItem[];
    answer?: ChoiceAnswerDto | undefined;

    constructor(data?: IChoiceQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new ChoiceQuestionValidation();
            this.choices = [];
        }
        this._discriminator = "ChoiceQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? ChoiceQuestionValidation.fromJS(_data["validation"]) : new ChoiceQuestionValidation();
            this.multiSelection = _data["multiSelection"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(SelectionItem.fromJS(item));
            }
            this.answer = _data["answer"] ? ChoiceAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ChoiceQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoiceQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["multiSelection"] = this.multiSelection;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ChoiceQuestionDto {
        const json = this.toJSON();
        let result = new ChoiceQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IChoiceQuestionDto extends IQuestionDto {
    validation: ChoiceQuestionValidation;
    multiSelection: boolean;
    choices: SelectionItem[];
    answer?: ChoiceAnswerDto | undefined;
}

export class TextQuestionDto extends QuestionDto implements ITextQuestionDto {
    validation!: TextQuestionValidation;
    multiline!: boolean;
    answer?: TextAnswerDto | undefined;

    constructor(data?: ITextQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new TextQuestionValidation();
        }
        this._discriminator = "TextQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? TextQuestionValidation.fromJS(_data["validation"]) : new TextQuestionValidation();
            this.multiline = _data["multiline"];
            this.answer = _data["answer"] ? TextAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TextQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["multiline"] = this.multiline;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): TextQuestionDto {
        const json = this.toJSON();
        let result = new TextQuestionDto();
        result.init(json);
        return result;
    }
}

export interface ITextQuestionDto extends IQuestionDto {
    validation: TextQuestionValidation;
    multiline: boolean;
    answer?: TextAnswerDto | undefined;
}

export class NumberQuestionDto extends QuestionDto implements INumberQuestionDto {
    validation!: NumberQuestionValidation;
    answer?: NumberAnswerDto | undefined;

    constructor(data?: INumberQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new NumberQuestionValidation();
        }
        this._discriminator = "NumberQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? NumberQuestionValidation.fromJS(_data["validation"]) : new NumberQuestionValidation();
            this.answer = _data["answer"] ? NumberAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): NumberQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NumberQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): NumberQuestionDto {
        const json = this.toJSON();
        let result = new NumberQuestionDto();
        result.init(json);
        return result;
    }
}

export interface INumberQuestionDto extends IQuestionDto {
    validation: NumberQuestionValidation;
    answer?: NumberAnswerDto | undefined;
}

export class DateQuestionDto extends QuestionDto implements IDateQuestionDto {
    validation!: DateQuestionValidation;
    answer?: DateAnswerDto | undefined;

    constructor(data?: IDateQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new DateQuestionValidation();
        }
        this._discriminator = "DateQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? DateQuestionValidation.fromJS(_data["validation"]) : new DateQuestionValidation();
            this.answer = _data["answer"] ? DateAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateQuestionDto {
        const json = this.toJSON();
        let result = new DateQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IDateQuestionDto extends IQuestionDto {
    validation: DateQuestionValidation;
    answer?: DateAnswerDto | undefined;
}

export class TimeQuestionDto extends QuestionDto implements ITimeQuestionDto {
    minuteIncrements?: number | undefined;
    validation!: TimeQuestionValidation;
    answer?: TimeAnswerDto | undefined;

    constructor(data?: ITimeQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new TimeQuestionValidation();
        }
        this._discriminator = "TimeQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minuteIncrements = _data["minuteIncrements"];
            this.validation = _data["validation"] ? TimeQuestionValidation.fromJS(_data["validation"]) : new TimeQuestionValidation();
            this.answer = _data["answer"] ? TimeAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TimeQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minuteIncrements"] = this.minuteIncrements;
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): TimeQuestionDto {
        const json = this.toJSON();
        let result = new TimeQuestionDto();
        result.init(json);
        return result;
    }
}

export interface ITimeQuestionDto extends IQuestionDto {
    minuteIncrements?: number | undefined;
    validation: TimeQuestionValidation;
    answer?: TimeAnswerDto | undefined;
}

export class DateTimeQuestionDto extends QuestionDto implements IDateTimeQuestionDto {
    minuteIncrements?: number | undefined;
    validation!: DateTimeQuestionValidation;
    answer?: DateTimeAnswerDto | undefined;

    constructor(data?: IDateTimeQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new DateTimeQuestionValidation();
        }
        this._discriminator = "DateTimeQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minuteIncrements = _data["minuteIncrements"];
            this.validation = _data["validation"] ? DateTimeQuestionValidation.fromJS(_data["validation"]) : new DateTimeQuestionValidation();
            this.answer = _data["answer"] ? DateTimeAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DateTimeQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minuteIncrements"] = this.minuteIncrements;
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): DateTimeQuestionDto {
        const json = this.toJSON();
        let result = new DateTimeQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IDateTimeQuestionDto extends IQuestionDto {
    minuteIncrements?: number | undefined;
    validation: DateTimeQuestionValidation;
    answer?: DateTimeAnswerDto | undefined;
}

export class SliderQuestionDto extends QuestionDto implements ISliderQuestionDto {
    minLabel!: InternationalizedString;
    maxLabel!: InternationalizedString;
    range!: boolean;
    vertical!: boolean;
    steps?: number | undefined;
    validation!: SliderQuestionValidation;
    answer?: SliderAnswerDto | undefined;

    constructor(data?: ISliderQuestionDto) {
        super(data);
        if (!data) {
            this.minLabel = new InternationalizedString();
            this.maxLabel = new InternationalizedString();
            this.validation = new SliderQuestionValidation();
        }
        this._discriminator = "SliderQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minLabel = _data["minLabel"] ? InternationalizedString.fromJS(_data["minLabel"]) : new InternationalizedString();
            this.maxLabel = _data["maxLabel"] ? InternationalizedString.fromJS(_data["maxLabel"]) : new InternationalizedString();
            this.range = _data["range"];
            this.vertical = _data["vertical"];
            this.steps = _data["steps"];
            this.validation = _data["validation"] ? SliderQuestionValidation.fromJS(_data["validation"]) : new SliderQuestionValidation();
            this.answer = _data["answer"] ? SliderAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): SliderQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SliderQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minLabel"] = this.minLabel ? this.minLabel.toJSON() : <any>undefined;
        data["maxLabel"] = this.maxLabel ? this.maxLabel.toJSON() : <any>undefined;
        data["range"] = this.range;
        data["vertical"] = this.vertical;
        data["steps"] = this.steps;
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): SliderQuestionDto {
        const json = this.toJSON();
        let result = new SliderQuestionDto();
        result.init(json);
        return result;
    }
}

export interface ISliderQuestionDto extends IQuestionDto {
    minLabel: InternationalizedString;
    maxLabel: InternationalizedString;
    range: boolean;
    vertical: boolean;
    steps?: number | undefined;
    validation: SliderQuestionValidation;
    answer?: SliderAnswerDto | undefined;
}

export class ContainerQuestionDto extends QuestionDto implements IContainerQuestionDto {
    validation!: ContainerQuestionValidation;
    multiSelection!: boolean;
    containerType!: ContainerType;
    containerId!: string;
    answer?: ContainerAnswerDto | undefined;

    constructor(data?: IContainerQuestionDto) {
        super(data);
        if (!data) {
            this.validation = new ContainerQuestionValidation();
        }
        this._discriminator = "ContainerQuestionDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.validation = _data["validation"] ? ContainerQuestionValidation.fromJS(_data["validation"]) : new ContainerQuestionValidation();
            this.multiSelection = _data["multiSelection"];
            this.containerType = _data["containerType"];
            this.containerId = _data["containerId"];
            this.answer = _data["answer"] ? ContainerAnswerDto.fromJS(_data["answer"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ContainerQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerQuestionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validation"] = this.validation ? this.validation.toJSON() : <any>undefined;
        data["multiSelection"] = this.multiSelection;
        data["containerType"] = this.containerType;
        data["containerId"] = this.containerId;
        data["answer"] = this.answer ? this.answer.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ContainerQuestionDto {
        const json = this.toJSON();
        let result = new ContainerQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IContainerQuestionDto extends IQuestionDto {
    validation: ContainerQuestionValidation;
    multiSelection: boolean;
    containerType: ContainerType;
    containerId: string;
    answer?: ContainerAnswerDto | undefined;
}

export enum ContainerType {
    Questionnaire = "questionnaire",
    ContextObject = "contextObject",
    AppPage = "appPage",
}

export class ContainerCondition extends Condition implements IContainerCondition {

    constructor(data?: IContainerCondition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContainerCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContainerCondition {
        const json = this.toJSON();
        let result = new ContainerCondition();
        result.init(json);
        return result;
    }
}

export interface IContainerCondition extends ICondition {
}

export class LanguageDto extends TenantEntityDto implements ILanguageDto {
    name!: string;
    code!: string;
    icon?: AssetDto | undefined;
    fallbackLanguages!: LanguageDto[];

    constructor(data?: ILanguageDto) {
        super(data);
        if (!data) {
            this.fallbackLanguages = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.icon = _data["icon"] ? AssetDto.fromJS(_data["icon"]) : <any>undefined;
            if (Array.isArray(_data["fallbackLanguages"])) {
                this.fallbackLanguages = [] as any;
                for (let item of _data["fallbackLanguages"])
                    this.fallbackLanguages!.push(LanguageDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        if (Array.isArray(this.fallbackLanguages)) {
            data["fallbackLanguages"] = [];
            for (let item of this.fallbackLanguages)
                data["fallbackLanguages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): LanguageDto {
        const json = this.toJSON();
        let result = new LanguageDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageDto extends ITenantEntityDto {
    name: string;
    code: string;
    icon?: AssetDto | undefined;
    fallbackLanguages: LanguageDto[];
}

export abstract class SharingOption implements ISharingOption {
    id!: string;
    name!: string;
    label!: InternationalizedString;
    condition?: SharingCondition | undefined;

    constructor(data?: ISharingOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new InternationalizedString();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"] ? InternationalizedString.fromJS(_data["label"]) : new InternationalizedString();
            this.condition = _data["condition"] ? SharingCondition.fromJS(_data["condition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SharingOption {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SharingOption' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        return data;
    }

    clone(): SharingOption {
        throw new Error("The abstract class 'SharingOption' cannot be instantiated.");
    }
}

export interface ISharingOption {
    id: string;
    name: string;
    label: InternationalizedString;
    condition?: SharingCondition | undefined;
}

export class ContainerSharingOption extends SharingOption implements IContainerSharingOption {
    type!: ContainerSharingType;

    constructor(data?: IContainerSharingOption) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): ContainerSharingOption {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerSharingOption();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }

    clone(): ContainerSharingOption {
        const json = this.toJSON();
        let result = new ContainerSharingOption();
        result.init(json);
        return result;
    }
}

export interface IContainerSharingOption extends ISharingOption {
    type: ContainerSharingType;
}

export enum ContainerSharingType {
    IndividualInstances = "individualInstances",
    EntireContainer = "entireContainer",
    Automatic = "automatic",
}

export class SharingCondition extends Condition implements ISharingCondition {

    constructor(data?: ISharingCondition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SharingCondition {
        data = typeof data === 'object' ? data : {};
        let result = new SharingCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): SharingCondition {
        const json = this.toJSON();
        let result = new SharingCondition();
        result.init(json);
        return result;
    }
}

export interface ISharingCondition extends ICondition {
}

export class AppInstallationDto implements IAppInstallationDto {
    appName!: string;
    pushToken!: string;
    pushPublicKey!: string;

    constructor(data?: IAppInstallationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.pushToken = _data["pushToken"];
            this.pushPublicKey = _data["pushPublicKey"];
        }
    }

    static fromJS(data: any): AppInstallationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppInstallationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["pushToken"] = this.pushToken;
        data["pushPublicKey"] = this.pushPublicKey;
        return data;
    }

    clone(): AppInstallationDto {
        const json = this.toJSON();
        let result = new AppInstallationDto();
        result.init(json);
        return result;
    }
}

export interface IAppInstallationDto {
    appName: string;
    pushToken: string;
    pushPublicKey: string;
}

export class RegisterAppInstallationCommand implements IRegisterAppInstallationCommand {
    deviceName!: string;
    deviceIdentifier!: string;
    deviceModel!: string;
    deviceOsVersion!: string;
    deviceLanguage!: string;
    deviceTimezone!: string;
    appIdentifier!: string;
    appPushToken!: string;
    appPushBase64PublicKey!: string;

    constructor(data?: IRegisterAppInstallationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"];
            this.deviceIdentifier = _data["deviceIdentifier"];
            this.deviceModel = _data["deviceModel"];
            this.deviceOsVersion = _data["deviceOsVersion"];
            this.deviceLanguage = _data["deviceLanguage"];
            this.deviceTimezone = _data["deviceTimezone"];
            this.appIdentifier = _data["appIdentifier"];
            this.appPushToken = _data["appPushToken"];
            this.appPushBase64PublicKey = _data["appPushBase64PublicKey"];
        }
    }

    static fromJS(data: any): RegisterAppInstallationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterAppInstallationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceIdentifier"] = this.deviceIdentifier;
        data["deviceModel"] = this.deviceModel;
        data["deviceOsVersion"] = this.deviceOsVersion;
        data["deviceLanguage"] = this.deviceLanguage;
        data["deviceTimezone"] = this.deviceTimezone;
        data["appIdentifier"] = this.appIdentifier;
        data["appPushToken"] = this.appPushToken;
        data["appPushBase64PublicKey"] = this.appPushBase64PublicKey;
        return data;
    }

    clone(): RegisterAppInstallationCommand {
        const json = this.toJSON();
        let result = new RegisterAppInstallationCommand();
        result.init(json);
        return result;
    }
}

export interface IRegisterAppInstallationCommand {
    deviceName: string;
    deviceIdentifier: string;
    deviceModel: string;
    deviceOsVersion: string;
    deviceLanguage: string;
    deviceTimezone: string;
    appIdentifier: string;
    appPushToken: string;
    appPushBase64PublicKey: string;
}

export class UnregisterAppInstallationCommand implements IUnregisterAppInstallationCommand {
    deviceIdentifier!: string;
    appIdentifier!: string;

    constructor(data?: IUnregisterAppInstallationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceIdentifier = _data["deviceIdentifier"];
            this.appIdentifier = _data["appIdentifier"];
        }
    }

    static fromJS(data: any): UnregisterAppInstallationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UnregisterAppInstallationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceIdentifier"] = this.deviceIdentifier;
        data["appIdentifier"] = this.appIdentifier;
        return data;
    }

    clone(): UnregisterAppInstallationCommand {
        const json = this.toJSON();
        let result = new UnregisterAppInstallationCommand();
        result.init(json);
        return result;
    }
}

export interface IUnregisterAppInstallationCommand {
    deviceIdentifier: string;
    appIdentifier: string;
}

export class ClientSettingDto implements IClientSettingDto {
    key!: string;
    value?: string | undefined;
    timestamp?: Date | undefined;

    constructor(data?: IClientSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }

    clone(): ClientSettingDto {
        const json = this.toJSON();
        let result = new ClientSettingDto();
        result.init(json);
        return result;
    }
}

export interface IClientSettingDto {
    key: string;
    value?: string | undefined;
    timestamp?: Date | undefined;
}

export class PaginatedListOfContextObjectDto implements IPaginatedListOfContextObjectDto {
    items!: ContextObjectDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfContextObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContextObjectDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfContextObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfContextObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfContextObjectDto {
        const json = this.toJSON();
        let result = new PaginatedListOfContextObjectDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfContextObjectDto {
    items: ContextObjectDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ContextObjectDto extends ContainerDto implements IContextObjectDto {

    constructor(data?: IContextObjectDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContextObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContextObjectDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContextObjectDto {
        const json = this.toJSON();
        let result = new ContextObjectDto();
        result.init(json);
        return result;
    }
}

export interface IContextObjectDto extends IContainerDto {
}

export class SortingParameter implements ISortingParameter {
    property!: string;
    direction!: SortDirection;

    constructor(data?: ISortingParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.property = _data["property"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): SortingParameter {
        data = typeof data === 'object' ? data : {};
        let result = new SortingParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        data["direction"] = this.direction;
        return data;
    }

    clone(): SortingParameter {
        const json = this.toJSON();
        let result = new SortingParameter();
        result.init(json);
        return result;
    }
}

export interface ISortingParameter {
    property: string;
    direction: SortDirection;
}

export enum SortDirection {
    Ascending = "ascending",
    Descending = "descending",
}

export abstract class ContainerDetailsDto extends TenantEntityDto implements IContainerDetailsDto {
    projectId?: string | undefined;
    name!: string;
    title!: InternationalizedString;
    description!: InternationalizedDocument;
    condition?: ContainerCondition | undefined;
    languages!: LanguageDto[];
    sharingOptions!: ContainerSharingOption[];

    constructor(data?: IContainerDetailsDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.description = new InternationalizedDocument();
            this.languages = [];
            this.sharingOptions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.description = _data["description"] ? InternationalizedDocument.fromJS(_data["description"]) : new InternationalizedDocument();
            this.condition = _data["condition"] ? ContainerCondition.fromJS(_data["condition"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            if (Array.isArray(_data["sharingOptions"])) {
                this.sharingOptions = [] as any;
                for (let item of _data["sharingOptions"])
                    this.sharingOptions!.push(ContainerSharingOption.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContainerDetailsDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContainerDetailsDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sharingOptions)) {
            data["sharingOptions"] = [];
            for (let item of this.sharingOptions)
                data["sharingOptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContainerDetailsDto {
        throw new Error("The abstract class 'ContainerDetailsDto' cannot be instantiated.");
    }
}

export interface IContainerDetailsDto extends ITenantEntityDto {
    projectId?: string | undefined;
    name: string;
    title: InternationalizedString;
    description: InternationalizedDocument;
    condition?: ContainerCondition | undefined;
    languages: LanguageDto[];
    sharingOptions: ContainerSharingOption[];
}

export class ContextObjectDetailsDto extends ContainerDetailsDto implements IContextObjectDetailsDto {

    constructor(data?: IContextObjectDetailsDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContextObjectDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContextObjectDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContextObjectDetailsDto {
        const json = this.toJSON();
        let result = new ContextObjectDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IContextObjectDetailsDto extends IContainerDetailsDto {
}

export class PaginatedListOfContextObjectInstanceDto implements IPaginatedListOfContextObjectInstanceDto {
    items!: ContextObjectInstanceDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfContextObjectInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContextObjectInstanceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfContextObjectInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfContextObjectInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfContextObjectInstanceDto {
        const json = this.toJSON();
        let result = new PaginatedListOfContextObjectInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfContextObjectInstanceDto {
    items: ContextObjectInstanceDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ContextObjectInstanceDto extends TenantEntityDto implements IContextObjectInstanceDto {
    name!: string;
    contextObjectId!: string;
    contextObjectName!: string;
    created!: Date;
    lastModified!: Date;
    sharingState!: SharingState;

    constructor(data?: IContextObjectInstanceDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.contextObjectId = _data["contextObjectId"];
            this.contextObjectName = _data["contextObjectName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.sharingState = _data["sharingState"];
        }
    }

    static override fromJS(data: any): ContextObjectInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContextObjectInstanceDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["contextObjectId"] = this.contextObjectId;
        data["contextObjectName"] = this.contextObjectName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["sharingState"] = this.sharingState;
        super.toJSON(data);
        return data;
    }

    clone(): ContextObjectInstanceDto {
        const json = this.toJSON();
        let result = new ContextObjectInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IContextObjectInstanceDto extends ITenantEntityDto {
    name: string;
    contextObjectId: string;
    contextObjectName: string;
    created: Date;
    lastModified: Date;
    sharingState: SharingState;
}

export enum SharingState {
    NotShared = "notShared",
    SharedByMe = "sharedByMe",
    SharedWithMe = "sharedWithMe",
}

export class ContextObjectInstanceDetailsDto extends TenantEntityDto implements IContextObjectInstanceDetailsDto {
    name!: string;
    contextObjectId!: string;
    contextObjectName!: string;
    created!: Date;
    lastModified!: Date;
    sharingOptions!: ContainerSharingOption[];
    contents!: ContentDto[];
    sharingState!: SharingState;
    sharingPartners!: SharingPartnerDto[];

    constructor(data?: IContextObjectInstanceDetailsDto) {
        super(data);
        if (!data) {
            this.sharingOptions = [];
            this.contents = [];
            this.sharingPartners = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.contextObjectId = _data["contextObjectId"];
            this.contextObjectName = _data["contextObjectName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            if (Array.isArray(_data["sharingOptions"])) {
                this.sharingOptions = [] as any;
                for (let item of _data["sharingOptions"])
                    this.sharingOptions!.push(ContainerSharingOption.fromJS(item));
            }
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ContentDto.fromJS(item));
            }
            this.sharingState = _data["sharingState"];
            if (Array.isArray(_data["sharingPartners"])) {
                this.sharingPartners = [] as any;
                for (let item of _data["sharingPartners"])
                    this.sharingPartners!.push(SharingPartnerDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContextObjectInstanceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContextObjectInstanceDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["contextObjectId"] = this.contextObjectId;
        data["contextObjectName"] = this.contextObjectName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        if (Array.isArray(this.sharingOptions)) {
            data["sharingOptions"] = [];
            for (let item of this.sharingOptions)
                data["sharingOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        data["sharingState"] = this.sharingState;
        if (Array.isArray(this.sharingPartners)) {
            data["sharingPartners"] = [];
            for (let item of this.sharingPartners)
                data["sharingPartners"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContextObjectInstanceDetailsDto {
        const json = this.toJSON();
        let result = new ContextObjectInstanceDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IContextObjectInstanceDetailsDto extends ITenantEntityDto {
    name: string;
    contextObjectId: string;
    contextObjectName: string;
    created: Date;
    lastModified: Date;
    sharingOptions: ContainerSharingOption[];
    contents: ContentDto[];
    sharingState: SharingState;
    sharingPartners: SharingPartnerDto[];
}

export class SharingPartnerDto implements ISharingPartnerDto {
    userId!: string;
    userGivenName?: string | undefined;
    userFamilyName?: string | undefined;
    userEmail?: string | undefined;

    constructor(data?: ISharingPartnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userGivenName = _data["userGivenName"];
            this.userFamilyName = _data["userFamilyName"];
            this.userEmail = _data["userEmail"];
        }
    }

    static fromJS(data: any): SharingPartnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SharingPartnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userGivenName"] = this.userGivenName;
        data["userFamilyName"] = this.userFamilyName;
        data["userEmail"] = this.userEmail;
        return data;
    }

    clone(): SharingPartnerDto {
        const json = this.toJSON();
        let result = new SharingPartnerDto();
        result.init(json);
        return result;
    }
}

export interface ISharingPartnerDto {
    userId: string;
    userGivenName?: string | undefined;
    userFamilyName?: string | undefined;
    userEmail?: string | undefined;
}

export class UpdateContextObjectInstanceCommand implements IUpdateContextObjectInstanceCommand {
    contextObjectId!: string;
    contextObjectInstanceId!: string;
    values!: ValueDto[];

    constructor(data?: IUpdateContextObjectInstanceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contextObjectId = _data["contextObjectId"];
            this.contextObjectInstanceId = _data["contextObjectInstanceId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContextObjectInstanceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContextObjectInstanceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contextObjectId"] = this.contextObjectId;
        data["contextObjectInstanceId"] = this.contextObjectInstanceId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateContextObjectInstanceCommand {
        const json = this.toJSON();
        let result = new UpdateContextObjectInstanceCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateContextObjectInstanceCommand {
    contextObjectId: string;
    contextObjectInstanceId: string;
    values: ValueDto[];
}

export class QrCodeDto implements IQrCodeDto {
    base64QrCode!: string;
    qrCodeUrl!: string;

    constructor(data?: IQrCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64QrCode = _data["base64QrCode"];
            this.qrCodeUrl = _data["qrCodeUrl"];
        }
    }

    static fromJS(data: any): QrCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new QrCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64QrCode"] = this.base64QrCode;
        data["qrCodeUrl"] = this.qrCodeUrl;
        return data;
    }

    clone(): QrCodeDto {
        const json = this.toJSON();
        let result = new QrCodeDto();
        result.init(json);
        return result;
    }
}

export interface IQrCodeDto {
    base64QrCode: string;
    qrCodeUrl: string;
}

export class PaginatedListOfDeviceDto implements IPaginatedListOfDeviceDto {
    items!: DeviceDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfDeviceDto {
        const json = this.toJSON();
        let result = new PaginatedListOfDeviceDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfDeviceDto {
    items: DeviceDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export abstract class DeviceDto implements IDeviceDto {
    id!: string;
    name!: string;
    identifier!: string;

    protected _discriminator: string;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "DeviceDto";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "MobilePhoneDto") {
            let result = new MobilePhoneDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DeviceDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        return data;
    }

    clone(): DeviceDto {
        throw new Error("The abstract class 'DeviceDto' cannot be instantiated.");
    }
}

export interface IDeviceDto {
    id: string;
    name: string;
    identifier: string;
}

export class MobilePhoneDto extends DeviceDto implements IMobilePhoneDto {
    model!: string;

    constructor(data?: IMobilePhoneDto) {
        super(data);
        this._discriminator = "MobilePhoneDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.model = _data["model"];
        }
    }

    static override fromJS(data: any): MobilePhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new MobilePhoneDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model;
        super.toJSON(data);
        return data;
    }

    clone(): MobilePhoneDto {
        const json = this.toJSON();
        let result = new MobilePhoneDto();
        result.init(json);
        return result;
    }
}

export interface IMobilePhoneDto extends IDeviceDto {
    model: string;
}

export abstract class DeviceDetailsDto implements IDeviceDetailsDto {
    id!: string;
    name!: string;
    identifier!: string;

    protected _discriminator: string;

    constructor(data?: IDeviceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "DeviceDetailsDto";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): DeviceDetailsDto {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "MobilePhoneDetailsDto") {
            let result = new MobilePhoneDetailsDto();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DeviceDetailsDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        return data;
    }

    clone(): DeviceDetailsDto {
        throw new Error("The abstract class 'DeviceDetailsDto' cannot be instantiated.");
    }
}

export interface IDeviceDetailsDto {
    id: string;
    name: string;
    identifier: string;
}

export class MobilePhoneDetailsDto extends DeviceDetailsDto implements IMobilePhoneDetailsDto {
    model!: string;
    osVersion!: string;
    language!: string;
    timezone!: string;
    installedApps!: AppInstallationDto[];

    constructor(data?: IMobilePhoneDetailsDto) {
        super(data);
        if (!data) {
            this.installedApps = [];
        }
        this._discriminator = "MobilePhoneDetailsDto";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.model = _data["model"];
            this.osVersion = _data["osVersion"];
            this.language = _data["language"];
            this.timezone = _data["timezone"];
            if (Array.isArray(_data["installedApps"])) {
                this.installedApps = [] as any;
                for (let item of _data["installedApps"])
                    this.installedApps!.push(AppInstallationDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MobilePhoneDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MobilePhoneDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model;
        data["osVersion"] = this.osVersion;
        data["language"] = this.language;
        data["timezone"] = this.timezone;
        if (Array.isArray(this.installedApps)) {
            data["installedApps"] = [];
            for (let item of this.installedApps)
                data["installedApps"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): MobilePhoneDetailsDto {
        const json = this.toJSON();
        let result = new MobilePhoneDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IMobilePhoneDetailsDto extends IDeviceDetailsDto {
    model: string;
    osVersion: string;
    language: string;
    timezone: string;
    installedApps: AppInstallationDto[];
}

export class PaginatedListOfLanguageDto implements IPaginatedListOfLanguageDto {
    items!: LanguageDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfLanguageDto {
        const json = this.toJSON();
        let result = new PaginatedListOfLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfLanguageDto {
    items: LanguageDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class PaginatedListOfQuestionnaireDto implements IPaginatedListOfQuestionnaireDto {
    items!: QuestionnaireDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionnaireDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfQuestionnaireDto {
        const json = this.toJSON();
        let result = new PaginatedListOfQuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfQuestionnaireDto {
    items: QuestionnaireDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class QuestionnaireDto extends ContainerDto implements IQuestionnaireDto {
    instantiationMode!: QuestionnaireInstantiationMode;

    constructor(data?: IQuestionnaireDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.instantiationMode = _data["instantiationMode"];
        }
    }

    static override fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instantiationMode"] = this.instantiationMode;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireDto {
        const json = this.toJSON();
        let result = new QuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireDto extends IContainerDto {
    instantiationMode: QuestionnaireInstantiationMode;
}

export enum QuestionnaireInstantiationMode {
    None = "none",
    Manual = "manual",
    Auto = "auto",
    Both = "both",
}

export class QuestionnaireDetailsDto extends ContainerDetailsDto implements IQuestionnaireDetailsDto {
    instantiationMode!: QuestionnaireInstantiationMode;
    created!: Date;
    lastModified!: Date;

    constructor(data?: IQuestionnaireDetailsDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.instantiationMode = _data["instantiationMode"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuestionnaireDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instantiationMode"] = this.instantiationMode;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireDetailsDto {
        const json = this.toJSON();
        let result = new QuestionnaireDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireDetailsDto extends IContainerDetailsDto {
    instantiationMode: QuestionnaireInstantiationMode;
    created: Date;
    lastModified: Date;
}

export class PaginatedListOfQuestionnaireInstanceDto implements IPaginatedListOfQuestionnaireInstanceDto {
    items!: QuestionnaireInstanceDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfQuestionnaireInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuestionnaireInstanceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfQuestionnaireInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfQuestionnaireInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfQuestionnaireInstanceDto {
        const json = this.toJSON();
        let result = new PaginatedListOfQuestionnaireInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfQuestionnaireInstanceDto {
    items: QuestionnaireInstanceDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class QuestionnaireInstanceDto extends TenantEntityDto implements IQuestionnaireInstanceDto {
    name!: string;
    questionnaireId!: string;
    questionnaireName!: string;
    questionnaireTitle!: InternationalizedString;
    created!: Date;
    lastModified!: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable!: boolean;
    state!: QuestionnaireInstanceState;
    sharingState!: SharingState;

    constructor(data?: IQuestionnaireInstanceDto) {
        super(data);
        if (!data) {
            this.questionnaireTitle = new InternationalizedString();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.questionnaireId = _data["questionnaireId"];
            this.questionnaireName = _data["questionnaireName"];
            this.questionnaireTitle = _data["questionnaireTitle"] ? InternationalizedString.fromJS(_data["questionnaireTitle"]) : new InternationalizedString();
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.hidden = _data["hidden"] ? new Date(_data["hidden"].toString()) : <any>undefined;
            this.editable = _data["editable"];
            this.state = _data["state"];
            this.sharingState = _data["sharingState"];
        }
    }

    static override fromJS(data: any): QuestionnaireInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireInstanceDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireName"] = this.questionnaireName;
        data["questionnaireTitle"] = this.questionnaireTitle ? this.questionnaireTitle.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["hidden"] = this.hidden ? this.hidden.toISOString() : <any>undefined;
        data["editable"] = this.editable;
        data["state"] = this.state;
        data["sharingState"] = this.sharingState;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireInstanceDto {
        const json = this.toJSON();
        let result = new QuestionnaireInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireInstanceDto extends ITenantEntityDto {
    name: string;
    questionnaireId: string;
    questionnaireName: string;
    questionnaireTitle: InternationalizedString;
    created: Date;
    lastModified: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable: boolean;
    state: QuestionnaireInstanceState;
    sharingState: SharingState;
}

export enum QuestionnaireInstanceState {
    NotStarted = "notStarted",
    InProgress = "inProgress",
    Completed = "completed",
}

export class QuestionnaireInstanceDetailsDto extends TenantEntityDto implements IQuestionnaireInstanceDetailsDto {
    name!: string;
    questionnaireId!: string;
    questionnaireName!: string;
    questionnaireTitle!: InternationalizedString;
    sharingOptions!: ContainerSharingOption[];
    created!: Date;
    lastModified!: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable!: boolean;
    state!: QuestionnaireInstanceState;
    pages!: ContentPageDto[];
    languages!: LanguageDto[];
    sharingState!: SharingState;
    sharingPartners!: SharingPartnerDto[];

    constructor(data?: IQuestionnaireInstanceDetailsDto) {
        super(data);
        if (!data) {
            this.questionnaireTitle = new InternationalizedString();
            this.sharingOptions = [];
            this.pages = [];
            this.languages = [];
            this.sharingPartners = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.questionnaireId = _data["questionnaireId"];
            this.questionnaireName = _data["questionnaireName"];
            this.questionnaireTitle = _data["questionnaireTitle"] ? InternationalizedString.fromJS(_data["questionnaireTitle"]) : new InternationalizedString();
            if (Array.isArray(_data["sharingOptions"])) {
                this.sharingOptions = [] as any;
                for (let item of _data["sharingOptions"])
                    this.sharingOptions!.push(ContainerSharingOption.fromJS(item));
            }
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.hidden = _data["hidden"] ? new Date(_data["hidden"].toString()) : <any>undefined;
            this.editable = _data["editable"];
            this.state = _data["state"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(ContentPageDto.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.sharingState = _data["sharingState"];
            if (Array.isArray(_data["sharingPartners"])) {
                this.sharingPartners = [] as any;
                for (let item of _data["sharingPartners"])
                    this.sharingPartners!.push(SharingPartnerDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuestionnaireInstanceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireInstanceDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireName"] = this.questionnaireName;
        data["questionnaireTitle"] = this.questionnaireTitle ? this.questionnaireTitle.toJSON() : <any>undefined;
        if (Array.isArray(this.sharingOptions)) {
            data["sharingOptions"] = [];
            for (let item of this.sharingOptions)
                data["sharingOptions"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["hidden"] = this.hidden ? this.hidden.toISOString() : <any>undefined;
        data["editable"] = this.editable;
        data["state"] = this.state;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["sharingState"] = this.sharingState;
        if (Array.isArray(this.sharingPartners)) {
            data["sharingPartners"] = [];
            for (let item of this.sharingPartners)
                data["sharingPartners"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireInstanceDetailsDto {
        const json = this.toJSON();
        let result = new QuestionnaireInstanceDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireInstanceDetailsDto extends ITenantEntityDto {
    name: string;
    questionnaireId: string;
    questionnaireName: string;
    questionnaireTitle: InternationalizedString;
    sharingOptions: ContainerSharingOption[];
    created: Date;
    lastModified: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable: boolean;
    state: QuestionnaireInstanceState;
    pages: ContentPageDto[];
    languages: LanguageDto[];
    sharingState: SharingState;
    sharingPartners: SharingPartnerDto[];
}

export class UpdateQuestionnaireInstanceCommand implements IUpdateQuestionnaireInstanceCommand {
    questionnaireId!: string;
    questionnaireInstanceId!: string;
    answers?: AnswerDto[] | undefined;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    executionLanguageId?: string | undefined;

    constructor(data?: IUpdateQuestionnaireInstanceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionnaireId = _data["questionnaireId"];
            this.questionnaireInstanceId = _data["questionnaireInstanceId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerDto.fromJS(item));
            }
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.hidden = _data["hidden"] ? new Date(_data["hidden"].toString()) : <any>undefined;
            this.executionLanguageId = _data["executionLanguageId"];
        }
    }

    static fromJS(data: any): UpdateQuestionnaireInstanceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionnaireInstanceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireInstanceId"] = this.questionnaireInstanceId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["hidden"] = this.hidden ? this.hidden.toISOString() : <any>undefined;
        data["executionLanguageId"] = this.executionLanguageId;
        return data;
    }

    clone(): UpdateQuestionnaireInstanceCommand {
        const json = this.toJSON();
        let result = new UpdateQuestionnaireInstanceCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateQuestionnaireInstanceCommand {
    questionnaireId: string;
    questionnaireInstanceId: string;
    answers?: AnswerDto[] | undefined;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    executionLanguageId?: string | undefined;
}

export class PaginatedListOfSearchResultDto implements IPaginatedListOfSearchResultDto {
    items!: SearchResultDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfSearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchResultDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfSearchResultDto {
        const json = this.toJSON();
        let result = new PaginatedListOfSearchResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfSearchResultDto {
    items: SearchResultDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class SearchResultDto extends TenantEntityDto implements ISearchResultDto {
    projectId!: string;
    title?: string | undefined;
    teaser!: string;
    type!: SearchResultType;

    constructor(data?: ISearchResultDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.projectId = _data["projectId"];
            this.title = _data["title"];
            this.teaser = _data["teaser"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): SearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["title"] = this.title;
        data["teaser"] = this.teaser;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }

    clone(): SearchResultDto {
        const json = this.toJSON();
        let result = new SearchResultDto();
        result.init(json);
        return result;
    }
}

export interface ISearchResultDto extends ITenantEntityDto {
    projectId: string;
    title?: string | undefined;
    teaser: string;
    type: SearchResultType;
}

export enum SearchResultType {
    AppPage = "appPage",
    Unknown = "unknown",
}

export class PaginatedListOfStudyDto implements IPaginatedListOfStudyDto {
    items!: StudyDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfStudyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StudyDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfStudyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfStudyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfStudyDto {
        const json = this.toJSON();
        let result = new PaginatedListOfStudyDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfStudyDto {
    items: StudyDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export abstract class ProjectDto extends TenantEntityDto implements IProjectDto {
    name!: string;
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    languages!: LanguageDto[];
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant!: TenantDto;

    constructor(data?: IProjectDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.languages = [];
            this.tenant = new TenantDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.participationState = _data["participationState"];
            this.chiffre = _data["chiffre"];
            this.tenant = _data["tenant"] ? TenantDto.fromJS(_data["tenant"]) : new TenantDto();
        }
    }

    static override fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ProjectDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["participationState"] = this.participationState;
        data["chiffre"] = this.chiffre;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ProjectDto {
        throw new Error("The abstract class 'ProjectDto' cannot be instantiated.");
    }
}

export interface IProjectDto extends ITenantEntityDto {
    name: string;
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    languages: LanguageDto[];
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant: TenantDto;
}

export class StudyDto extends ProjectDto implements IStudyDto {

    constructor(data?: IStudyDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StudyDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): StudyDto {
        const json = this.toJSON();
        let result = new StudyDto();
        result.init(json);
        return result;
    }
}

export interface IStudyDto extends IProjectDto {
}

export enum ProjectParticipationState {
    NotParticipating = "notParticipating",
    Participating = "participating",
}

export class TenantDto implements ITenantDto {
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    asset?: AssetDto | undefined;
    languages!: LanguageDto[];
    participationState?: TenantParticipationState | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.languages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.participationState = _data["participationState"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["participationState"] = this.participationState;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    asset?: AssetDto | undefined;
    languages: LanguageDto[];
    participationState?: TenantParticipationState | undefined;
}

export enum TenantParticipationState {
    NotParticipating = "notParticipating",
    Participating = "participating",
}

export abstract class ProjectDetailsDto extends TenantEntityDto implements IProjectDetailsDto {
    name!: string;
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    description!: InternationalizedDocument;
    languages!: LanguageDto[];
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant!: TenantDetailsDto;

    constructor(data?: IProjectDetailsDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.description = new InternationalizedDocument();
            this.languages = [];
            this.tenant = new TenantDetailsDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.description = _data["description"] ? InternationalizedDocument.fromJS(_data["description"]) : new InternationalizedDocument();
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            this.participationState = _data["participationState"];
            this.chiffre = _data["chiffre"];
            this.tenant = _data["tenant"] ? TenantDetailsDto.fromJS(_data["tenant"]) : new TenantDetailsDto();
        }
    }

    static override fromJS(data: any): ProjectDetailsDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ProjectDetailsDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        data["participationState"] = this.participationState;
        data["chiffre"] = this.chiffre;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ProjectDetailsDto {
        throw new Error("The abstract class 'ProjectDetailsDto' cannot be instantiated.");
    }
}

export interface IProjectDetailsDto extends ITenantEntityDto {
    name: string;
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    description: InternationalizedDocument;
    languages: LanguageDto[];
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant: TenantDetailsDto;
}

export class StudyDetailsDto extends ProjectDetailsDto implements IStudyDetailsDto {

    constructor(data?: IStudyDetailsDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StudyDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudyDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): StudyDetailsDto {
        const json = this.toJSON();
        let result = new StudyDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IStudyDetailsDto extends IProjectDetailsDto {
}

export class TenantDetailsDto implements ITenantDetailsDto {
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    description!: InternationalizedDocument;
    languages!: LanguageDto[];
    asset?: AssetDto | undefined;
    participationState?: TenantParticipationState | undefined;

    constructor(data?: ITenantDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.description = new InternationalizedDocument();
            this.languages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.description = _data["description"] ? InternationalizedDocument.fromJS(_data["description"]) : new InternationalizedDocument();
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            this.participationState = _data["participationState"];
        }
    }

    static fromJS(data: any): TenantDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["participationState"] = this.participationState;
        return data;
    }

    clone(): TenantDetailsDto {
        const json = this.toJSON();
        let result = new TenantDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDetailsDto {
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    description: InternationalizedDocument;
    languages: LanguageDto[];
    asset?: AssetDto | undefined;
    participationState?: TenantParticipationState | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}