//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CurrentUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getCurrentUser(signal?: AbortSignal): Promise<UserDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailsDto>(null as any);
    }

    updateCurrentUser(command: UpdateCurrentUserCommand, signal?: AbortSignal): Promise<UserDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCurrentUser(_response);
        });
    }

    protected processUpdateCurrentUser(response: Response): Promise<UserDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailsDto>(null as any);
    }

    deleteCurrentUser(command: DeleteCurrentUserCommand, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/current-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCurrentUser(_response);
        });
    }

    protected processDeleteCurrentUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCurrentUserPersonalData(signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/personal-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserPersonalData(_response);
        });
    }

    protected processGetCurrentUserPersonalData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    updateCurrentUserPassword(command: UpdateCurrentUserPasswordCommand, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCurrentUserPassword(_response);
        });
    }

    protected processUpdateCurrentUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getCurrentUserTenants(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/tenants?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserTenants(_response);
        });
    }

    protected processGetCurrentUserTenants(response: Response): Promise<PaginatedListOfTenantDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantDto>(null as any);
    }

    getCurrentUserStudies(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, states?: ProjectParticipationState[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantStudyDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/studies?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserStudies(_response);
        });
    }

    protected processGetCurrentUserStudies(response: Response): Promise<PaginatedListOfTenantStudyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantStudyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantStudyDto>(null as any);
    }

    getCurrentUserQuestionnaires(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, instantiationModes?: QuestionnaireInstantiationMode[] | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantQuestionnaireDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/questionnaires?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (instantiationModes !== undefined && instantiationModes !== null)
            instantiationModes && instantiationModes.forEach(item => { url_ += "instantiationModes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserQuestionnaires(_response);
        });
    }

    protected processGetCurrentUserQuestionnaires(response: Response): Promise<PaginatedListOfTenantQuestionnaireDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantQuestionnaireDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantQuestionnaireDto>(null as any);
    }

    getCurrentUserQuestionnaireInstances(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, from?: Date | null | undefined, until?: Date | null | undefined, states?: QuestionnaireInstanceState[] | null | undefined, showHidden?: boolean | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantQuestionnaireInstanceDto> {
        let url_ = this.baseUrl + "/api/v1/public/current-user/questionnaire-instances?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (until !== undefined && until !== null)
            url_ += "until=" + encodeURIComponent(until ? "" + until.toISOString() : "") + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (showHidden === null)
            throw new Error("The parameter 'showHidden' cannot be null.");
        else if (showHidden !== undefined)
            url_ += "showHidden=" + encodeURIComponent("" + showHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUserQuestionnaireInstances(_response);
        });
    }

    protected processGetCurrentUserQuestionnaireInstances(response: Response): Promise<PaginatedListOfTenantQuestionnaireInstanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantQuestionnaireInstanceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantQuestionnaireInstanceDto>(null as any);
    }
}

export class StudiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getPublicStudies(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantStudyDto> {
        let url_ = this.baseUrl + "/api/v1/public/studies/studies/public?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicStudies(_response);
        });
    }

    protected processGetPublicStudies(response: Response): Promise<PaginatedListOfTenantStudyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantStudyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantStudyDto>(null as any);
    }
}

export class TenantsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getTenants(pageNumber?: number | undefined, pageSize?: number | undefined, sorting?: SortingParameter[] | null | undefined, search?: string | null | undefined, signal?: AbortSignal): Promise<PaginatedListOfTenantDto> {
        let url_ = this.baseUrl + "/api/v1/public/tenants?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sorting !== undefined && sorting !== null)
            sorting && sorting.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "sorting[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTenants(_response);
        });
    }

    protected processGetTenants(response: Response): Promise<PaginatedListOfTenantDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTenantDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTenantDto>(null as any);
    }

    getTenant(id: string, signal?: AbortSignal): Promise<TenantDetailsDto> {
        let url_ = this.baseUrl + "/api/v1/public/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTenant(_response);
        });
    }

    protected processGetTenant(response: Response): Promise<TenantDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantDetailsDto>(null as any);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createAnonymousUser(command: CreateAnonymousUserCommand, signal?: AbortSignal): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/v1/public/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAnonymousUser(_response);
        });
    }

    protected processCreateAnonymousUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }
}

export class UserDetailsDto implements IUserDetailsDto {
    id!: string;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    honorificPrefix?: string | undefined;
    givenName?: string | undefined;
    additionalName?: string | undefined;
    familyName?: string | undefined;
    honorificSuffix?: string | undefined;
    streetAddress?: string | undefined;
    addressLevel1?: string | undefined;
    addressLevel2?: string | undefined;
    addressLevel3?: string | undefined;
    addressLevel4?: string | undefined;
    country?: string | undefined;
    postalCode?: string | undefined;
    language?: string | undefined;
    birthDay?: Date | undefined;
    sex?: string | undefined;
    roles!: RoleDto[];

    constructor(data?: IUserDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.honorificPrefix = _data["honorificPrefix"];
            this.givenName = _data["givenName"];
            this.additionalName = _data["additionalName"];
            this.familyName = _data["familyName"];
            this.honorificSuffix = _data["honorificSuffix"];
            this.streetAddress = _data["streetAddress"];
            this.addressLevel1 = _data["addressLevel1"];
            this.addressLevel2 = _data["addressLevel2"];
            this.addressLevel3 = _data["addressLevel3"];
            this.addressLevel4 = _data["addressLevel4"];
            this.country = _data["country"];
            this.postalCode = _data["postalCode"];
            this.language = _data["language"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.sex = _data["sex"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["honorificPrefix"] = this.honorificPrefix;
        data["givenName"] = this.givenName;
        data["additionalName"] = this.additionalName;
        data["familyName"] = this.familyName;
        data["honorificSuffix"] = this.honorificSuffix;
        data["streetAddress"] = this.streetAddress;
        data["addressLevel1"] = this.addressLevel1;
        data["addressLevel2"] = this.addressLevel2;
        data["addressLevel3"] = this.addressLevel3;
        data["addressLevel4"] = this.addressLevel4;
        data["country"] = this.country;
        data["postalCode"] = this.postalCode;
        data["language"] = this.language;
        data["birthDay"] = this.birthDay ? formatDate(this.birthDay) : <any>undefined;
        data["sex"] = this.sex;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDetailsDto {
        const json = this.toJSON();
        let result = new UserDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IUserDetailsDto {
    id: string;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    honorificPrefix?: string | undefined;
    givenName?: string | undefined;
    additionalName?: string | undefined;
    familyName?: string | undefined;
    honorificSuffix?: string | undefined;
    streetAddress?: string | undefined;
    addressLevel1?: string | undefined;
    addressLevel2?: string | undefined;
    addressLevel3?: string | undefined;
    addressLevel4?: string | undefined;
    country?: string | undefined;
    postalCode?: string | undefined;
    language?: string | undefined;
    birthDay?: Date | undefined;
    sex?: string | undefined;
    roles: RoleDto[];
}

export class RoleDto implements IRoleDto {
    id!: string;
    name!: string;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: string;
    name: string;
}

export class UpdateCurrentUserCommand implements IUpdateCurrentUserCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    honorificPrefix?: string | undefined;
    givenName?: string | undefined;
    additionalName?: string | undefined;
    familyName?: string | undefined;
    honorificSuffix?: string | undefined;
    streetAddress?: string | undefined;
    addressLevel1?: string | undefined;
    addressLevel2?: string | undefined;
    addressLevel3?: string | undefined;
    addressLevel4?: string | undefined;
    country?: string | undefined;
    postalCode?: string | undefined;
    language?: string | undefined;
    birthDay?: Date | undefined;
    sex?: string | undefined;

    constructor(data?: IUpdateCurrentUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.honorificPrefix = _data["honorificPrefix"];
            this.givenName = _data["givenName"];
            this.additionalName = _data["additionalName"];
            this.familyName = _data["familyName"];
            this.honorificSuffix = _data["honorificSuffix"];
            this.streetAddress = _data["streetAddress"];
            this.addressLevel1 = _data["addressLevel1"];
            this.addressLevel2 = _data["addressLevel2"];
            this.addressLevel3 = _data["addressLevel3"];
            this.addressLevel4 = _data["addressLevel4"];
            this.country = _data["country"];
            this.postalCode = _data["postalCode"];
            this.language = _data["language"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.sex = _data["sex"];
        }
    }

    static fromJS(data: any): UpdateCurrentUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrentUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["honorificPrefix"] = this.honorificPrefix;
        data["givenName"] = this.givenName;
        data["additionalName"] = this.additionalName;
        data["familyName"] = this.familyName;
        data["honorificSuffix"] = this.honorificSuffix;
        data["streetAddress"] = this.streetAddress;
        data["addressLevel1"] = this.addressLevel1;
        data["addressLevel2"] = this.addressLevel2;
        data["addressLevel3"] = this.addressLevel3;
        data["addressLevel4"] = this.addressLevel4;
        data["country"] = this.country;
        data["postalCode"] = this.postalCode;
        data["language"] = this.language;
        data["birthDay"] = this.birthDay ? formatDate(this.birthDay) : <any>undefined;
        data["sex"] = this.sex;
        return data;
    }

    clone(): UpdateCurrentUserCommand {
        const json = this.toJSON();
        let result = new UpdateCurrentUserCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateCurrentUserCommand {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    honorificPrefix?: string | undefined;
    givenName?: string | undefined;
    additionalName?: string | undefined;
    familyName?: string | undefined;
    honorificSuffix?: string | undefined;
    streetAddress?: string | undefined;
    addressLevel1?: string | undefined;
    addressLevel2?: string | undefined;
    addressLevel3?: string | undefined;
    addressLevel4?: string | undefined;
    country?: string | undefined;
    postalCode?: string | undefined;
    language?: string | undefined;
    birthDay?: Date | undefined;
    sex?: string | undefined;
}

export class UpdateCurrentUserPasswordCommand implements IUpdateCurrentUserPasswordCommand {
    oldPassword!: string;
    newPassword!: string;

    constructor(data?: IUpdateCurrentUserPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdateCurrentUserPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrentUserPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): UpdateCurrentUserPasswordCommand {
        const json = this.toJSON();
        let result = new UpdateCurrentUserPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateCurrentUserPasswordCommand {
    oldPassword: string;
    newPassword: string;
}

export class DeleteCurrentUserCommand implements IDeleteCurrentUserCommand {
    password!: string;

    constructor(data?: IDeleteCurrentUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): DeleteCurrentUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCurrentUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }

    clone(): DeleteCurrentUserCommand {
        const json = this.toJSON();
        let result = new DeleteCurrentUserCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteCurrentUserCommand {
    password: string;
}

export class PaginatedListOfTenantDto implements IPaginatedListOfTenantDto {
    items!: TenantDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfTenantDto {
        const json = this.toJSON();
        let result = new PaginatedListOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfTenantDto {
    items: TenantDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TenantDto implements ITenantDto {
    id!: string;
    name!: string;
    slug!: string;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: string;
    name: string;
    slug: string;
}

export class SortingParameter implements ISortingParameter {
    property!: string;
    direction!: SortDirection;

    constructor(data?: ISortingParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.property = _data["property"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): SortingParameter {
        data = typeof data === 'object' ? data : {};
        let result = new SortingParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        data["direction"] = this.direction;
        return data;
    }

    clone(): SortingParameter {
        const json = this.toJSON();
        let result = new SortingParameter();
        result.init(json);
        return result;
    }
}

export interface ISortingParameter {
    property: string;
    direction: SortDirection;
}

export enum SortDirection {
    Ascending = "ascending",
    Descending = "descending",
}

export class PaginatedListOfTenantStudyDto implements IPaginatedListOfTenantStudyDto {
    items!: TenantStudyDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTenantStudyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantStudyDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTenantStudyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTenantStudyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfTenantStudyDto {
        const json = this.toJSON();
        let result = new PaginatedListOfTenantStudyDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfTenantStudyDto {
    items: TenantStudyDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TenantStudyDto implements ITenantStudyDto {
    tenant!: TenantDto;
    study!: StudyDto;

    constructor(data?: ITenantStudyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tenant = new TenantDto();
            this.study = new StudyDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"] ? TenantDto.fromJS(_data["tenant"]) : new TenantDto();
            this.study = _data["study"] ? StudyDto.fromJS(_data["study"]) : new StudyDto();
        }
    }

    static fromJS(data: any): TenantStudyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantStudyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["study"] = this.study ? this.study.toJSON() : <any>undefined;
        return data;
    }

    clone(): TenantStudyDto {
        const json = this.toJSON();
        let result = new TenantStudyDto();
        result.init(json);
        return result;
    }
}

export interface ITenantStudyDto {
    tenant: TenantDto;
    study: StudyDto;
}

export class TenantEntityDto implements ITenantEntityDto {
    id!: string;
    tenantId!: string;

    constructor(data?: ITenantEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): TenantEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): TenantEntityDto {
        const json = this.toJSON();
        let result = new TenantEntityDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEntityDto {
    id: string;
    tenantId: string;
}

export abstract class ProjectDto extends TenantEntityDto implements IProjectDto {
    name!: string;
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    languages!: LanguageDto[];
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant!: TenantDto2;

    constructor(data?: IProjectDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.languages = [];
            this.tenant = new TenantDto2();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.participationState = _data["participationState"];
            this.chiffre = _data["chiffre"];
            this.tenant = _data["tenant"] ? TenantDto2.fromJS(_data["tenant"]) : new TenantDto2();
        }
    }

    static override fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ProjectDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["participationState"] = this.participationState;
        data["chiffre"] = this.chiffre;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ProjectDto {
        throw new Error("The abstract class 'ProjectDto' cannot be instantiated.");
    }
}

export interface IProjectDto extends ITenantEntityDto {
    name: string;
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    asset?: AssetDto | undefined;
    published?: Date | undefined;
    languages: LanguageDto[];
    participationState?: ProjectParticipationState | undefined;
    chiffre?: string | undefined;
    tenant: TenantDto2;
}

export class StudyDto extends ProjectDto implements IStudyDto {

    constructor(data?: IStudyDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StudyDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudyDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): StudyDto {
        const json = this.toJSON();
        let result = new StudyDto();
        result.init(json);
        return result;
    }
}

export interface IStudyDto extends IProjectDto {
}

export class InternationalizedString implements IInternationalizedString {
    translations!: { [key: string]: string; };

    constructor(data?: IInternationalizedString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.translations = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key];
                }
            }
        }
    }

    static fromJS(data: any): InternationalizedString {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalizedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = (<any>this.translations)[key];
            }
        }
        return data;
    }

    clone(): InternationalizedString {
        const json = this.toJSON();
        let result = new InternationalizedString();
        result.init(json);
        return result;
    }
}

export interface IInternationalizedString {
    translations: { [key: string]: string; };
}

export class AssetDto extends TenantEntityDto implements IAssetDto {
    file?: FileDto | undefined;
    name!: string;
    description?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    x?: number | undefined;
    y?: number | undefined;
    contentType!: string;

    constructor(data?: IAssetDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.file = _data["file"] ? FileDto.fromJS(_data["file"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.contentType = _data["contentType"];
        }
    }

    static override fromJS(data: any): AssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["width"] = this.width;
        data["height"] = this.height;
        data["x"] = this.x;
        data["y"] = this.y;
        data["contentType"] = this.contentType;
        super.toJSON(data);
        return data;
    }

    clone(): AssetDto {
        const json = this.toJSON();
        let result = new AssetDto();
        result.init(json);
        return result;
    }
}

export interface IAssetDto extends ITenantEntityDto {
    file?: FileDto | undefined;
    name: string;
    description?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    x?: number | undefined;
    y?: number | undefined;
    contentType: string;
}

export class FileDto implements IFileDto {
    url?: string | undefined;
    id!: string;
    name!: string;
    created!: Date;
    lastModified!: Date;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    url?: string | undefined;
    id: string;
    name: string;
    created: Date;
    lastModified: Date;
}

export class LanguageDto extends TenantEntityDto implements ILanguageDto {
    name!: string;
    code!: string;
    icon?: AssetDto | undefined;
    fallbackLanguages!: LanguageDto[];

    constructor(data?: ILanguageDto) {
        super(data);
        if (!data) {
            this.fallbackLanguages = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.icon = _data["icon"] ? AssetDto.fromJS(_data["icon"]) : <any>undefined;
            if (Array.isArray(_data["fallbackLanguages"])) {
                this.fallbackLanguages = [] as any;
                for (let item of _data["fallbackLanguages"])
                    this.fallbackLanguages!.push(LanguageDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        if (Array.isArray(this.fallbackLanguages)) {
            data["fallbackLanguages"] = [];
            for (let item of this.fallbackLanguages)
                data["fallbackLanguages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): LanguageDto {
        const json = this.toJSON();
        let result = new LanguageDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageDto extends ITenantEntityDto {
    name: string;
    code: string;
    icon?: AssetDto | undefined;
    fallbackLanguages: LanguageDto[];
}

export enum ProjectParticipationState {
    NotParticipating = "notParticipating",
    Participating = "participating",
}

export class TenantDto2 implements ITenantDto2 {
    title!: InternationalizedString;
    shortDescription!: InternationalizedString;
    asset?: AssetDto | undefined;
    languages!: LanguageDto[];
    participationState?: TenantParticipationState | undefined;

    constructor(data?: ITenantDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = new InternationalizedString();
            this.shortDescription = new InternationalizedString();
            this.languages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.shortDescription = _data["shortDescription"] ? InternationalizedString.fromJS(_data["shortDescription"]) : new InternationalizedString();
            this.asset = _data["asset"] ? AssetDto.fromJS(_data["asset"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            this.participationState = _data["participationState"];
        }
    }

    static fromJS(data: any): TenantDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["shortDescription"] = this.shortDescription ? this.shortDescription.toJSON() : <any>undefined;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["participationState"] = this.participationState;
        return data;
    }

    clone(): TenantDto2 {
        const json = this.toJSON();
        let result = new TenantDto2();
        result.init(json);
        return result;
    }
}

export interface ITenantDto2 {
    title: InternationalizedString;
    shortDescription: InternationalizedString;
    asset?: AssetDto | undefined;
    languages: LanguageDto[];
    participationState?: TenantParticipationState | undefined;
}

export enum TenantParticipationState {
    NotParticipating = "notParticipating",
    Participating = "participating",
}

export class PaginatedListOfTenantQuestionnaireDto implements IPaginatedListOfTenantQuestionnaireDto {
    items!: TenantQuestionnaireDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTenantQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantQuestionnaireDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTenantQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTenantQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfTenantQuestionnaireDto {
        const json = this.toJSON();
        let result = new PaginatedListOfTenantQuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfTenantQuestionnaireDto {
    items: TenantQuestionnaireDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TenantQuestionnaireDto implements ITenantQuestionnaireDto {
    tenant!: TenantDto;
    questionnaire!: QuestionnaireDto;

    constructor(data?: ITenantQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tenant = new TenantDto();
            this.questionnaire = new QuestionnaireDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"] ? TenantDto.fromJS(_data["tenant"]) : new TenantDto();
            this.questionnaire = _data["questionnaire"] ? QuestionnaireDto.fromJS(_data["questionnaire"]) : new QuestionnaireDto();
        }
    }

    static fromJS(data: any): TenantQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        return data;
    }

    clone(): TenantQuestionnaireDto {
        const json = this.toJSON();
        let result = new TenantQuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface ITenantQuestionnaireDto {
    tenant: TenantDto;
    questionnaire: QuestionnaireDto;
}

export abstract class ContainerDto extends TenantEntityDto implements IContainerDto {
    created!: Date;
    lastModified!: Date;
    projectId?: string | undefined;
    name!: string;
    title!: InternationalizedString;
    condition?: ContainerCondition | undefined;
    languages!: LanguageDto[];
    sharingOptions!: ContainerSharingOption[];

    constructor(data?: IContainerDto) {
        super(data);
        if (!data) {
            this.title = new InternationalizedString();
            this.languages = [];
            this.sharingOptions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.title = _data["title"] ? InternationalizedString.fromJS(_data["title"]) : new InternationalizedString();
            this.condition = _data["condition"] ? ContainerCondition.fromJS(_data["condition"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageDto.fromJS(item));
            }
            if (Array.isArray(_data["sharingOptions"])) {
                this.sharingOptions = [] as any;
                for (let item of _data["sharingOptions"])
                    this.sharingOptions!.push(ContainerSharingOption.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContainerDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContainerDto' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sharingOptions)) {
            data["sharingOptions"] = [];
            for (let item of this.sharingOptions)
                data["sharingOptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): ContainerDto {
        throw new Error("The abstract class 'ContainerDto' cannot be instantiated.");
    }
}

export interface IContainerDto extends ITenantEntityDto {
    created: Date;
    lastModified: Date;
    projectId?: string | undefined;
    name: string;
    title: InternationalizedString;
    condition?: ContainerCondition | undefined;
    languages: LanguageDto[];
    sharingOptions: ContainerSharingOption[];
}

export class QuestionnaireDto extends ContainerDto implements IQuestionnaireDto {
    instantiationMode!: QuestionnaireInstantiationMode;

    constructor(data?: IQuestionnaireDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.instantiationMode = _data["instantiationMode"];
        }
    }

    static override fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instantiationMode"] = this.instantiationMode;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireDto {
        const json = this.toJSON();
        let result = new QuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireDto extends IContainerDto {
    instantiationMode: QuestionnaireInstantiationMode;
}

export enum QuestionnaireInstantiationMode {
    None = "none",
    Manual = "manual",
    Auto = "auto",
    Both = "both",
}

export abstract class Condition implements ICondition {
    expression!: string;

    constructor(data?: ICondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expression = _data["expression"];
        }
    }

    static fromJS(data: any): Condition {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Condition' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expression"] = this.expression;
        return data;
    }

    clone(): Condition {
        throw new Error("The abstract class 'Condition' cannot be instantiated.");
    }
}

export interface ICondition {
    expression: string;
}

export class ContainerCondition extends Condition implements IContainerCondition {

    constructor(data?: IContainerCondition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContainerCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): ContainerCondition {
        const json = this.toJSON();
        let result = new ContainerCondition();
        result.init(json);
        return result;
    }
}

export interface IContainerCondition extends ICondition {
}

export abstract class SharingOption implements ISharingOption {
    id!: string;
    name!: string;
    label!: InternationalizedString;
    condition?: SharingCondition | undefined;

    constructor(data?: ISharingOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.label = new InternationalizedString();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"] ? InternationalizedString.fromJS(_data["label"]) : new InternationalizedString();
            this.condition = _data["condition"] ? SharingCondition.fromJS(_data["condition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SharingOption {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SharingOption' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label ? this.label.toJSON() : <any>undefined;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        return data;
    }

    clone(): SharingOption {
        throw new Error("The abstract class 'SharingOption' cannot be instantiated.");
    }
}

export interface ISharingOption {
    id: string;
    name: string;
    label: InternationalizedString;
    condition?: SharingCondition | undefined;
}

export class ContainerSharingOption extends SharingOption implements IContainerSharingOption {
    type!: ContainerSharingType;

    constructor(data?: IContainerSharingOption) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): ContainerSharingOption {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerSharingOption();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }

    clone(): ContainerSharingOption {
        const json = this.toJSON();
        let result = new ContainerSharingOption();
        result.init(json);
        return result;
    }
}

export interface IContainerSharingOption extends ISharingOption {
    type: ContainerSharingType;
}

export enum ContainerSharingType {
    IndividualInstances = "individualInstances",
    EntireContainer = "entireContainer",
    Automatic = "automatic",
}

export class SharingCondition extends Condition implements ISharingCondition {

    constructor(data?: ISharingCondition) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SharingCondition {
        data = typeof data === 'object' ? data : {};
        let result = new SharingCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }

    clone(): SharingCondition {
        const json = this.toJSON();
        let result = new SharingCondition();
        result.init(json);
        return result;
    }
}

export interface ISharingCondition extends ICondition {
}

export class PaginatedListOfTenantQuestionnaireInstanceDto implements IPaginatedListOfTenantQuestionnaireInstanceDto {
    items!: TenantQuestionnaireInstanceDto[];
    pageNumber!: number;
    pageSize!: number;
    totalCount!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IPaginatedListOfTenantQuestionnaireInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantQuestionnaireInstanceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTenantQuestionnaireInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTenantQuestionnaireInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): PaginatedListOfTenantQuestionnaireInstanceDto {
        const json = this.toJSON();
        let result = new PaginatedListOfTenantQuestionnaireInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IPaginatedListOfTenantQuestionnaireInstanceDto {
    items: TenantQuestionnaireInstanceDto[];
    pageNumber: number;
    pageSize: number;
    totalCount: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TenantQuestionnaireInstanceDto implements ITenantQuestionnaireInstanceDto {
    tenant!: TenantDto;
    questionnaireInstance!: QuestionnaireInstanceDto;

    constructor(data?: ITenantQuestionnaireInstanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tenant = new TenantDto();
            this.questionnaireInstance = new QuestionnaireInstanceDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant = _data["tenant"] ? TenantDto.fromJS(_data["tenant"]) : new TenantDto();
            this.questionnaireInstance = _data["questionnaireInstance"] ? QuestionnaireInstanceDto.fromJS(_data["questionnaireInstance"]) : new QuestionnaireInstanceDto();
        }
    }

    static fromJS(data: any): TenantQuestionnaireInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantQuestionnaireInstanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["questionnaireInstance"] = this.questionnaireInstance ? this.questionnaireInstance.toJSON() : <any>undefined;
        return data;
    }

    clone(): TenantQuestionnaireInstanceDto {
        const json = this.toJSON();
        let result = new TenantQuestionnaireInstanceDto();
        result.init(json);
        return result;
    }
}

export interface ITenantQuestionnaireInstanceDto {
    tenant: TenantDto;
    questionnaireInstance: QuestionnaireInstanceDto;
}

export class QuestionnaireInstanceDto extends TenantEntityDto implements IQuestionnaireInstanceDto {
    name!: string;
    questionnaireId!: string;
    questionnaireName!: string;
    questionnaireTitle!: InternationalizedString;
    created!: Date;
    lastModified!: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable?: boolean;
    state!: QuestionnaireInstanceState;
    sharingState!: SharingState;

    constructor(data?: IQuestionnaireInstanceDto) {
        super(data);
        if (!data) {
            this.questionnaireTitle = new InternationalizedString();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.questionnaireId = _data["questionnaireId"];
            this.questionnaireName = _data["questionnaireName"];
            this.questionnaireTitle = _data["questionnaireTitle"] ? InternationalizedString.fromJS(_data["questionnaireTitle"]) : new InternationalizedString();
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.hidden = _data["hidden"] ? new Date(_data["hidden"].toString()) : <any>undefined;
            this.editable = _data["editable"];
            this.state = _data["state"];
            this.sharingState = _data["sharingState"];
        }
    }

    static override fromJS(data: any): QuestionnaireInstanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireInstanceDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireName"] = this.questionnaireName;
        data["questionnaireTitle"] = this.questionnaireTitle ? this.questionnaireTitle.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["hidden"] = this.hidden ? this.hidden.toISOString() : <any>undefined;
        data["editable"] = this.editable;
        data["state"] = this.state;
        data["sharingState"] = this.sharingState;
        super.toJSON(data);
        return data;
    }

    clone(): QuestionnaireInstanceDto {
        const json = this.toJSON();
        let result = new QuestionnaireInstanceDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireInstanceDto extends ITenantEntityDto {
    name: string;
    questionnaireId: string;
    questionnaireName: string;
    questionnaireTitle: InternationalizedString;
    created: Date;
    lastModified: Date;
    started?: Date | undefined;
    completed?: Date | undefined;
    hidden?: Date | undefined;
    editable?: boolean;
    state: QuestionnaireInstanceState;
    sharingState: SharingState;
}

export enum QuestionnaireInstanceState {
    NotStarted = "notStarted",
    InProgress = "inProgress",
    Completed = "completed",
}

export enum SharingState {
    NotShared = "notShared",
    SharedByMe = "sharedByMe",
    SharedWithMe = "sharedWithMe",
}

export class TenantDetailsDto implements ITenantDetailsDto {
    id!: string;
    name!: string;
    slug!: string;
    url!: string;

    constructor(data?: ITenantDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): TenantDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["url"] = this.url;
        return data;
    }

    clone(): TenantDetailsDto {
        const json = this.toJSON();
        let result = new TenantDetailsDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDetailsDto {
    id: string;
    name: string;
    slug: string;
    url: string;
}

export class UserDto implements IUserDto {
    id!: string;
    userName!: string;
    email?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: string;
    userName: string;
    email?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;
}

export class CreateAnonymousUserCommand implements ICreateAnonymousUserCommand {
    password!: string;

    constructor(data?: ICreateAnonymousUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateAnonymousUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAnonymousUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }

    clone(): CreateAnonymousUserCommand {
        const json = this.toJSON();
        let result = new CreateAnonymousUserCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateAnonymousUserCommand {
    password: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}